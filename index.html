<!--
 * Copyright (c) 2024 OneNok_HK
 * Licensed under the MIT License. See LICENSE file in the project root for full license information.
-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>particles life</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            background-color: black;
        }

        #controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            transition: right 0.3s ease-in-out;
            z-index: 1000;
        }

        #controls > div:not(#controls > div > div) {
            margin-top: 20px;
        }

        #controls.visible {
            right: 0;
        }

        #toggle-controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.7);
            transition: right 0.3s ease-in-out, opacity 0.3s ease;
            opacity: 0;
        }

        #toggle-controls:hover {
            opacity: 1;
        }

        /*canvas {
            border: 1px solid;
            border-color: rgb(63, 63, 63);
        }*/

        /* æŒ‰éˆ•çµ„æ¨£å¼ */
        .button-group {
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        h3 {
            color: #272727;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .button-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .styled-button {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            border: none;
            padding: 10px 20px;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .styled-button:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .styled-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* æ€§èƒ½æ•¸æ“šé¡¯ç¤ºå€åŸŸæ¨£å¼ */
        #performance-data {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        #performance-data h3 {
            color: #fff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #performance-data p {
            color: #ffffff;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        #performance-data span {
            color: #5dff62;
            font-weight: bold;
        }

        /* æ§åˆ¶å…ƒç´ æ¨£å¼ */
        input[type="range"] {
            width: 200px;
            height: 5px;
            border-radius: 5px;
            background: #4d4d4d;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
            background: #6e6e6e;
        }

        input[type="number"] {
            width: 70px;
            padding: 2px 5px;
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            font-size: 13px;
            height: 20px;
            box-sizing: border-box;
            margin-top: 5px;
        }

        input[type="number"]:focus,
        select:focus {
            border-color: #6e6e6e;
            outline: none;
            box-shadow: 0 0 5px rgba(110, 110, 110, 0.5);
        }

        select {
            padding: 2px 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            color: #ffffff;
            font-size: 13px;
            height: 20px;
        }

        /* æ¨™ç±¤æ¨£å¼ */
        label {
            color: #d0d0d0;
            margin-right: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* è¤‡é¸æ¡†æ¨£å¼ */
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 10px;
        }

        /* ä¸€èˆ¬æ¨™ç±¤å’Œæ–‡å­—çš„é»˜èªé¡è‰² */
        label {
            color: #2e2e2e;
        }

        /* ä¸€èˆ¬æ®µè½æ–‡å­— */
        p {
            color: #2e2e2e;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* æœ‰ç‰¹å®šèƒŒæ™¯çš„å…ƒç´ ä¿æŒç™½è‰²æ–‡å­— */
        #performance-data p {
            color: #ffffff;
        }

        /* ä¿æŒæŒ‰éˆ•æ–‡å­—ç‚ºç™½è‰²ï¼Œå› ç‚ºæŒ‰éˆ•æœ‰æ·±è‰²èƒŒæ™¯ */
        .styled-button {
            color: #d0d0d0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* æ€§èƒ½æ•¸æ“šå€åŸŸä¿æŒç™½è‰²æ–‡å­— */
        #performance-data h3,
        #performance-data p {
            color: #ffffff;
        }

        /* æ€§èƒ½æ•¸æ“šä¸­çš„æ•¸å€¼ä¿æŒç¶ è‰² */
        #performance-data span {
            color: #5dff62;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* åˆ‡æ›é–‹é—œå®¹å™¨ */
        .toggle-container {
            margin: 10px 0;
            display: flex;
        }

        /* æ¨™ç±¤æ¨£å¼ */
        .toggle-label {
            width: fit-content;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            pointer-events: none;
        }

        /* åˆ‡æ›é–‹é—œå¤–è§€ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        /* éš±è—åŸå§‹è¤‡é¸æ¡†ï¼Œä½†ä¿æŒåœ¨æ»‘å¡Šä½ç½® */
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1; /* ç¢ºä¿è¤‡é¸æ¡†åœ¨æœ€ä¸Šå±¤ */
            margin: 0; /* ç§»é™¤é»˜èªé‚Šè· */
        }

        /* æ»‘å¡Šæ¨£å¼ */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4d4d4d;
            transition: .3s;
            border-radius: 24px;
            pointer-events: none; /* ç¢ºä¿æ»‘å¡Šä¸æœƒå¹²æ“¾é»æ“Šäº‹ä»¶ */
        }

        /* æ»‘å¡Šçš„åœ“å½¢æŒ‰éˆ• */
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: #d0d0d0;
            transition: .3s;
            border-radius: 50%;
        }

        /* é¸ä¸­ç‹€æ…‹çš„æ¨£å¼ */
        input:checked + .slider {
            background-color: #4CAF50;
        }

        /* æ»‘å¡Šæ‡¸åœæ•ˆæœ */
        .slider:hover {
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        /* é¸ä¸­ç‹€æ…‹ä¸‹åœ“å½¢æŒ‰éˆ•çš„ä½ç½® */
        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #ffffff;
        }

        /* ç²’å­è¦å‰‡å®¹å™¨ï¼ˆæ–°å¢æ¨£å¼ï¼‰ */
        .rules-container {
            background: rgba(0, 0, 0, 0.2); 
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        .rules-container > div:not(.no-background) {
            background: rgba(0, 0, 0, 0.1); 
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        .matrix-container {
            overflow-x: auto;
            display: flex;
        }

        .matrix-container input[type="number"] {
            width: 100%;
            padding: 2px;
            border: none;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }


        .particle-type {
            background: rgba(0, 0, 0, 0.1);
            padding: 0 5px 5px 5px;
            border-radius: 5px;
        }
        .description {
            color: #222222;
            font-size: 12px;
            margin: 0;
        }

        .matrix-table {
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .color-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-inputs input[type="color"],
        .color-inputs input[type="range"] {
            flex: 1;
        }
    </style>
</head>

<body>
    <button id="toggle-controls">â˜°</button>
    <div id="controls">
        <div class="rules-container">
            <h3>ğŸ“‹ ç²’å­ç³»çµ±è¨­ç½®</h3>
            <div class="control-section">
                <h3>åŸºæœ¬è¨­ç½®</h3>
                <div>
                    <label for="particle-types">ç²’å­é¡å‹æ•¸é‡:</label>
                    <input type="number" id="particle-types" min="1" max="10" value="3">
                </div>
            </div>
            
            <div id="particle-settings" class="no-background">
                <!-- å‹•æ…‹ç”Ÿæˆçš„ç²’å­è¨­ç½® -->
            </div>
            
            <div id="interaction-matrix" class="no-background">
                <!-- å‹•æ…‹ç”Ÿæˆçš„äº¤äº’çŸ©é™£ -->
            </div>
        </div>
        
        <div class="toggle-container">
            <label for="isThrough" class="toggle-label">ğŸ” ç„¡é‚Šç•Œæ¨¡å¼</label>
            <div class="toggle-switch">
                <input type="checkbox" id="isThrough">
                <span class="slider"></span>
            </div>
        </div>

        <!-- å°‡æŒ‰éˆ•çµ„é‡çµ„ç¹”ä¸¦æ·»åŠ æ¨£å¼ -->
        <div class="button-group">
            <!-- åŸºæœ¬æ“ä½œæŒ‰éˆ• -->
            <div class="control-section">
                <h3>ğŸ® åŸºæœ¬æ“ä½œ</h3>
                <div class="button-container">
                    <button id="randomize-button" class="styled-button">ğŸ² éš¨æ©ŸåŒ–æ‰€æœ‰å€¼</button>
                    <button id="restart-button" class="styled-button">ğŸ”„ é‡æ–°é–‹å§‹éŠæˆ²</button>
                    <button id="randomize-and-restart-button" class="styled-button">ğŸ¯ éš¨æ©ŸåŒ–ä¸¦é‡æ–°é–‹å§‹</button>
                </div>
            </div>

            <!-- è¦å‰‡å°å…¥å°å‡ºæŒ‰éˆ• -->
            <div class="control-section">
                <h3>ğŸ’¾ è¦å‰‡ç®¡ç†</h3>
                <div class="button-container">
                    <button id="export-rules" class="styled-button">ğŸ“¤ åŒ¯å‡ºè¦å‰‡</button>
                    <button id="import-rules" class="styled-button">ğŸ“¥ å°å…¥è¦å‰‡</button>
                    <button id="import-rules-and-restart" class="styled-button">ğŸ“‹ å°å…¥è¦å‰‡ä¸¦é‡æ–°é–‹å§‹</button>
                </div>
            </div>
            <input type="file" id="import-file" style="display: none;">
        </div>

        <!-- æ·»åŠ æ»‘é¼ å¸å¼•åŠ›æ»‘å¡Š -->
        <div>
            <label for="mouse-force">æ»‘é¼ å¸å¼•åŠ›:</label>
            <input type="range" id="mouse-force" min="0" max="200" step="0.1" value="100">
            <input type="number" id="mouse-force-number" min="0" max="200" step="0.1" value="100">
        </div>
        <div class="control-section">
            <h3>ç‰©ç†åƒæ•¸</h3>
            <div class="control-item">
                <label for="t-half">æ‘©æ“¦åŠè¡°æœŸ(ç§’):</label>
                <input type="range" id="t-half" min="0.001" max="0.1" step="0.001" value="0.020">
                <input type="number" id="t-half-number" min="0.001" max="0.1" step="0.001" value="0.020">
            </div>
        </div>

        <div>
            <label for="updateInterval">æ›´æ–°é–“éš”(ms):</label>
            <input type="range" id="updateInterval" min="1" max="50" step="0.01" value="16.66">
            <input type="number" id="updateInterval-number" min="1" max="50" step="0.01" value="16.66">
            <select id="updateInterval-unit">
                <option value="33.33">30 UPS</option>
                <option value="16.66" selected>60 UPS</option>
                <option value="8.33">120 UPS</option>
                <option value="6.94">144 UPS</option>
                <option value="6.06">165 UPS</option>
                <option value="4.16">240 UPS</option>
                <option value="2.77">360 UPS</option>
                <option value="2.08">480 UPS</option>
                <option value="2.00">500 UPS</option>
                <option value="1.85">540 UPS</option>
                <option value="1.66">600 UPS</option>
                <option value="1.38">720 UPS</option>
            </select>
            <p>UPS: Update Per Secondï¼Œæ¯ç§’æ›´æ–°æ¬¡æ•¸</p>
            <p>æ³¨æ„: æ›´æ–°é–“éš”è¶ŠçŸ­ï¼Œç²’å­é‹å‹•è¶Šæµæš¢ã€‚</p>
            <p class="description">ä½†å¦‚æœä½ çš„é›»è…¦ä¸¦ä¸èƒ½é‹è¡Œåˆ°é‚£éº¼çŸ­çš„æ›´æ–°é–“éš”ï¼Œ\né‚£éº¼ä½ çš„é›»è…¦å°±ç„¡æ³•é‹è¡Œåˆ°é‚£éº¼çŸ­çš„æ›´æ–°é–“éš”ã€‚</p>
        </div>

        <!-- åœ¨æ§åˆ¶é¢æ¿ä¸­æ·»åŠ æ€§èƒ½æ•¸æ“šé¡¯ç¤º -->
        <div id="performance-data">
            <h3>æ€§èƒ½æ•¸æ“š</h3>
            <p>æ¸²æŸ“FPS: <span id="fps"></span><br>(é€™ä¸¦ä¸æ˜¯éŠæˆ²æ¯ç§’æ›´æ–°æ¬¡æ•¸ã€‚)</p>
            <p>éŠæˆ²UPS: <span id="gameUPS"></span><br>(é€™æ˜¯éŠæˆ²æ¯ç§’æ›´æ–°æ¬¡æ•¸ã€‚)</p>
            <p>ç²’å­æ›´æ–°ç¸½æ™‚é–“: 
                <br>ç•¶å‰: <span id="total-time"></span> ms 
                <br>å¹³å‡: <span id="total-time-average"></span> ms
                <br>æœ€å¤§: <span id="total-time-max"></span> ms
            </p>
            <p>ç¶²æ ¼é‡ç½®æ™‚é–“: 
                <br>ç•¶å‰: <span id="grid-reset-time"></span> ms 
                <br>å¹³å‡: <span id="grid-reset-time-average"></span> ms
                <br>æœ€å¤§: <span id="grid-reset-time-max"></span> ms
                <br>å–®æ¬¡å¹³å‡: <span id="grid-reset-time-single-average"></span> ms
                <br>æ¯æ›´æ–°åŸ·è¡Œæ¬¡æ•¸: <span id="grid-reset-time-run-per-update"></span> æ¬¡
            </p>
            <p>å–å¾—é™„è¿‘ç²’å­æ™‚é–“: 
                <br>ç•¶å‰: <span id="get-nearby-time"></span> ms 
                <br>å¹³å‡: <span id="get-nearby-time-average"></span> ms
                <br>æœ€å¤§: <span id="get-nearby-time-max"></span> ms
                <br>å–®æ¬¡å¹³å‡: <span id="get-nearby-time-single-average"></span> ms
                <br>æ¯æ›´æ–°åŸ·è¡Œæ¬¡æ•¸: <span id="get-nearby-time-run-per-update"></span> æ¬¡
            </p>
            <p>é‡åŠ›å½±éŸ¿è¨ˆç®—æ™‚é–“: 
                <br>ç•¶å‰: <span id="g-Affect-Calc-time"></span> ms 
                <br>å¹³å‡: <span id="g-Affect-Calc-time-average"></span> ms
                <br>æœ€å¤§: <span id="g-Affect-Calc-time-max"></span> ms
                <br>å–®å€‹ç²’å­å¹³å‡: <span id="g-Affect-Calc-time-single-average"></span> ms
                <br>æ¯æ›´æ–°åŸ·è¡Œæ¬¡æ•¸: <span id="g-Affect-Calc-time-run-per-update"></span> æ¬¡
                </p>
            <p>æ›´æ–°ä½ç½®æ™‚é–“: 
                <br>ç•¶å‰: <span id="position-update-time"></span> ms 
                <br>å¹³å‡: <span id="position-update-time-average"></span> ms
                <br>æœ€å¤§: <span id="position-update-time-max"></span> ms
                <br>å–®æ¬¡å¹³å‡: <span id="position-update-time-single-average"></span> ms
                <br>æ¯æ›´æ–°åŸ·è¡Œæ¬¡æ•¸: <span id="position-update-time-run-per-update"></span> æ¬¡
            </p>
            <p>ç²’å­å½±éŸ¿ç¯„åœè¨ˆç®—æ™‚é–“: 
                <br>ç•¶å‰: <span id="Particle-Affect-Calc-time"></span> ms 
                <br>å¹³å‡: <span id="Particle-Affect-Calc-time-average"></span> ms
                <br>æœ€å¤§: <span id="Particle-Affect-Calc-time-max"></span> ms
            </p>
        </div>

        <!-- åœ¨æ§åˆ¶é¢æ¿ä¸­æ·»åŠ æ–°çš„æ§åˆ¶å…ƒç´  -->
        <div class="grid-controls">
            <h3>âŒ— ç¶²æ ¼è¨­ç½®</h3>
            <div class="toggle-container">
                <label for="showGrid" class="toggle-label">ğŸ”² é¡¯ç¤ºç¶²æ ¼</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="showGrid">
                    <span class="slider"></span>
                </div>
            </div>
            <div>
                <p>ç•¶å‰æ‰€é¸å–®å…ƒæ ¼: <span id="selected-cell"></span></p>
                <p>ç¶²æ ¼å¯¬åº¦: <span id="grid-width"></span></p>
                <p>ç¶²æ ¼é«˜åº¦: <span id="grid-height"></span></p>
            </div>
            <div>
                <label for="setectGridDistance">æ¨¡æ“¬ä½œç”¨ç¯„åœ: </label>
                <input type="range" id="setectGridDistance" min="10" max="500" step="10" value="250">
                <input type="number" id="setectGridDistance-number" min="10" max="500" step="10" value="250">
            </div>
            <div>
                <label for="cell-size">ç¶²æ ¼å¤§å°:</label>
                <input type="range" id="cell-size" min="10" max="100" step="1" value="50">
                <input type="number" id="cell-size-number" min="10" max="100" step="1" value="50">
            </div>
        </div>

        <!-- åœ¨æ€§èƒ½æ•¸æ“šé¡¯ç¤ºå€åŸŸä¹‹å¾Œæ·»åŠ ä»¥ä¸‹ä»£ç¢¼ -->
        <div>
            <h3>â˜¢ï¸ ç²’å­å½±éŸ¿ç¯„åœé¡¯ç¤º</h3>
            <div class="toggle-container">
                <label for="enableParticleAffcetRadiusShow" class="toggle-label">å•Ÿç”¨ç²’å­å½±éŸ¿ç¯„åœé¡¯ç¤º: </label>
                <div class="toggle-switch">
                    <input type="checkbox" id="enableParticleAffcetRadiusShow">
                    <span class="slider"></span>
                </div>
            </div>
            <div id="particle-affcet-radius-show" class="no-background">
                <!-- å‹•æ…‹ç”Ÿæˆçš„ç²’å­å½±éŸ¿ç¯„åœé¡¯ç¤ºè¨­ç½® -->
            </div>
            <div>
                <p>é¸ä¸­çš„ç²’å­ID: <span id="selectedParticleId">ç„¡</span></p>
                <p>é¸ä¸­çš„ç²’å­å±¬æ€§: <span id="selectedParticleProperty"></span></p>
                <div id="particle-nearby-particles" class="no-background">
                    <!-- å‹•æ…‹ç”Ÿæˆçš„ç²’å­ç¯„åœå…§çš„{i}è™Ÿç²’å­æ•¸é‡ -->
                </div>
            </div>
        </div>
        <div>
            <p style="font-size: 1.2em; font-weight: bold; color: #ff6b6b; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); margin: 15px 0;">ğŸ’¬ äº¤æµèˆ‡åé¥‹</p>
            <a href="https://github.com/onenok/ParticlesLife.html/issues" style="text-decoration: none; display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 6px; background: #24292e; color: white; width: fit-content; transition: background 0.2s;">
                <svg height="24" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="24" fill="currentColor">
                    <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
                </svg>
                <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">GitHub Issues</span>
            </a>
        </div>
    </div>
    <canvas id="board2d"></canvas>

    <script>
        // å‰µå»º Web Worker
        const worker = new Worker('particleWorker.js');
        // ç”¨æˆ¶å¯æ§åˆ¶æ•¸æ“šçš„åˆå§‹åŒ–
        const gameState = {
            // ç²’å­ç³»çµ±åŸºæœ¬è¨­ç½®
            particleTypes: 3,
            particleCounts: [250, 250, 250],
            particleColors: [
                'hsl(0, 100%, 50%)',   // ç´…è‰²
                'hsl(120, 100%, 50%)', // ç¶ è‰²
                'hsl(240, 100%, 50%)'  // è—è‰²
            ],
            particleGroups: [],
            // äº¤äº’çŸ©é™£
            forceMatrix: [
                [1, 0.5, 0],
                [0, 1, 0.5],
                [0.5, 0, 1]
            ],
            distanceMatrix: [
                [300, 300, 300],
                [300, 300, 300],
                [300, 300, 300]
            ],
            
            // ç‰©ç†åƒæ•¸
            tHalf: 0.020,         // æ‘©æ“¦åŠè¡°æœŸ
            dt: 1/144,           // æ™‚é–“æ­¥é•·
            
            // é¡¯ç¤ºè¨­ç½®
            isThrough: false,     // ç„¡é‚Šç•Œæ¨¡å¼
            showGrid: false,      // é¡¯ç¤ºç¶²æ ¼
            gridData: {
                cellSize: 50,
                width: 0,
                height: 0,
                selectedCell: null,
                nearbyCells: []
            },
            
            // æ»‘é¼ äº¤äº’
            mouseForce: 100,
            
            // å…¶ä»–è¨­ç½®
            setectGridDistance: 250,
            enableParticleAffcetRadiusShow: false,
            selectedParticleId: null,
            selectedParticleType: null,
            nearbyParticlesList: [],
            ballRadius: 1.5,
            RadiusShow: [true, true, true],
            // æ›´æ–°æ§åˆ¶
            updateInterval: 16.66    // ç´„ 60 FPS
        };
        document.addEventListener('DOMContentLoaded', () => {
            const canvas2d = document.getElementById("board2d");
            const ctx = canvas2d.getContext("2d");

            // ç§»é™¤ WebGL ç›¸é—œè®Šé‡
            /*
            let useWebGL = false; // ä¿ç•™é€™å€‹è®Šé‡ï¼Œä½†å§‹çµ‚ç‚º false
            */

            function updateCanvasSize() {
                const controlPanel = document.getElementById('controls');
                const isPanelVisible = controlPanel.classList.contains('visible');
                const width = document.documentElement.clientWidth - (isPanelVisible ? 300 : 0);
                const height = document.documentElement.clientHeight;

                canvas2d.width = width;
                canvas2d.height = height;

                // è¨­ç½® Canvas æ¨£å¼
                canvas2d.style.position = 'absolute';
                canvas2d.style.left = '0';
                canvas2d.style.top = '0';

                worker.postMessage({ type: 'updateCanvasSize', width, height });
            }

            function draw(particles, gridData) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);
                if (gameState.showGrid && gridData) {
                    drawGrid(ctx, gridData);
                }

                
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, gameState.ballRadius, 0, Math.PI * 2);
                    
                    if (gameState.enableParticleAffcetRadiusShow) {
                        if (gameState.selectedParticleId === null) {
                            ctx.fillStyle = 'gray';
                            ctx.fill();
                            ctx.closePath();
                        }else if (p.id === gameState.selectedParticleId) {
                            let isXOverflow = false;
                            let isYOverflow = false;
                            let newx = p.x;
                            let newy = p.y;
                            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                            ctx.fill();
                            ctx.closePath();
                            for (let i = 0; i < gameState.RadiusShow.length; i++) {
                                if (gameState.RadiusShow[i]) {
                                    hsl = gameState.particleColors[i];
                                    h = hsl.match(/hsl\((\d+),\s*\d+%,\s*\d+%\)/)[1];
                                    hsla = `hsla(${h}, 100%, 50%, 0.3)`;
                                    radius = gameState.distanceMatrix[gameState.selectedParticleType][i];
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                                    ctx.fillStyle = hsla;
                                    ctx.fill();
                                    ctx.closePath();
                                    if (throughCheckbox.checked) {
                                        isXOverflow = false;
                                        isYOverflow = false;
                                        newx = p.x;
                                        newy = p.y;
                                        if ((p.x < radius || p.x > canvas2d.width - radius)){
                                            isXOverflow = true;
                                            newx = p.x < radius ? p.x + canvas2d.width : p.x - canvas2d.width;
                                            ctx.beginPath();
                                            ctx.arc(newx, p.y, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if ((p.y < radius || p.y > canvas2d.height - radius)){
                                            isYOverflow = true;
                                            newy = p.y < radius ? p.y + canvas2d.height : p.y - canvas2d.height;
                                            ctx.beginPath();
                                            ctx.arc(p.x, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if (isXOverflow && isYOverflow) {
                                            ctx.beginPath();
                                            ctx.arc(newx, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                    }
                                }
                            }
                        } else { 
                            if (gameState.RadiusShow[p.type]) {
                                ctx.fillStyle = (gameState.nearbyParticlesList[p.type]||[]).includes(p) ? p.color : 'gray';
                                ctx.fill();
                                ctx.closePath();
                            }
                        }
                    } else {
                        ctx.fillStyle = p.isOutside ? 'white' : p.color;
                        ctx.fill();
                        ctx.closePath();
                    }
                });
            }

            function drawGrid(ctx, gridData) {
                //console.log(gridData);
                const { cellSize, width, height, selectedCell, nearbyCells } = gridData;
                const canvasWidth = canvas2d.width;
                const canvasHeight = canvas2d.height;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                // ç¹ªè£½å‚ç›´ç·š
                for (let x = 0; x <= width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, Math.min(height * cellSize, canvasHeight));
                    ctx.stroke();
                }

                // ç¹ªè£½æ°´å¹³ç·š
                for (let y = 0; y <= height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(Math.min(width * cellSize, canvasWidth), y * cellSize);
                    ctx.stroke();
                }

                // ç¹ªè£½é¸ä¸­çš„å–®å…ƒæ ¼å’Œé™„è¿‘çš„å–®å…ƒæ ¼
                if (selectedCell) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.fillRect(selectedCell.x * cellSize, selectedCell.y * cellSize, cellSize, cellSize);

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    nearbyCells.forEach(cell => {
                        ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                    });
                }
            }

            // åˆå§‹åŒ–éŠæˆ²å‡½æ•¸ä¿®æ”¹
            function initGame() {
                let performanceData = {
                    totalTime: 0,
                    totalTimeAll: [],
                    totalTimeMax: 0,
                    gridResetTime: 0,
                    gridResetTimeAll: [],
                    gridResetTimeMax: 0,
                    getNearbyTime: 0,
                    getNearbyTimeAll: [],
                    getNearbyTimeMax: 0,
                    gAffectCalcTime: 0,
                    gAffectCalcTimeAll: [],
                    gAffectCalcTimeMax: 0,
                    positionUpdateTime: 0,
                    positionUpdateTimeAll: [],
                    positionUpdateTimeMax: 0,
                    ParticleAffcetCalcTime: 0,
                    ParticleAffcetCalcTimeAll: [],
                    ParticleAffcetCalcTimeMax: 0
                };
                worker.postMessage({
                    type: 'init',
                    particleCounts: gameState.particleCounts,
                    canvasWidth: canvas2d.width,
                    canvasHeight: canvas2d.height,
                    particleColors: gameState.particleColors,
                    particleTypes: gameState.particleTypes,
                    performanceData: performanceData,
                    cellSize: gameState.gridData.cellSize
                });
            }

            // åˆå§‹åŒ– canvas å°ºå¯¸
            updateCanvasSize();

            // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
            window.addEventListener("resize", updateCanvasSize);

            // æ·»åŠ  FPS è¨ˆç®—ç›¸é—œè®Šé‡
            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 0;
            let gameFPS = 0;

            let particles = [];
            let performanceData = {
                totalTime: 0,
                totalTimeAll: [],
                totalTimeMax: 0,
                totalTimeAverage: 0,
                gridResetTime: 0,
                gridResetTimeAll: [],
                gridResetTimeMax: 0,
                gridResetTimeAverage: 0,
                getNearbyTime: 0,
                getNearbyTimeAll: [],
                getNearbyTimeMax: 0,
                getNearbyTimeAverage: 0,
                gAffectCalcTime: 0,
                gAffectCalcTimeAll: [],
                gAffectCalcTimeMax: 0,
                gAffectCalcTimeAverage: 0,
                positionUpdateTime: 0,
                positionUpdateTimeAll: [],
                positionUpdateTimeMax: 0,
                positionUpdateTimeAverage: 0,
                ParticleAffcetCalcTime: 0,
                ParticleAffcetCalcTimeAll: [],
                ParticleAffcetCalcTimeMax: 0,
                ParticleAffcetCalcTimeAverage: 0
            };
            let totalTimeAverageUpdateMs = 1000;
            let gridResetTimeAverageUpdateMs = 1000;
            let getNearbyTimeAverageUpdateMs = 1000;
            let gAffectCalcTimeAverageUpdateMs = 1000;
            let positionUpdateTimeAverageUpdateMs = 1000;
            let ParticleAffcetCalcTimeAverageUpdateMs = 1000;
            let totalTimeAverageUpdateLastTime = 0;
            let gridResetTimeAverageUpdateLastTime = 0;
            let getNearbyTimeAverageUpdateLastTime = 0;
            let gAffectCalcTimeAverageUpdateLastTime = 0;
            let positionUpdateTimeAverageUpdateLastTime = 0;
            let ParticleAffcetCalcTimeAverageUpdateLastTime = 0;
            function update() {
                // æ›´æ–°æ‰€é¸å–®å…ƒæ ¼çš„é¡¯ç¤º
                if (gameState.gridData.selectedCell) {
                    document.getElementById('selected-cell').textContent = `x: ${gameState.gridData.selectedCell.x}, y: ${gameState.gridData.selectedCell.y}`;
                } else {
                    document.getElementById('selected-cell').textContent = 'ç„¡';
                }
                draw(particles, gameState.gridData);
                if (performanceData.totalTime > performanceData.totalTimeMax) {
                    performanceData.totalTimeMax = performanceData.totalTime;
                }
                if (performanceData.gridResetTime > performanceData.gridResetTimeMax){
                    performanceData.gridResetTimeMax = performanceData.gridResetTime;
                }
                if (performanceData.getNearbyTime > performanceData.getNearbyTimeMax){
                    performanceData.getNearbyTimeMax = performanceData.getNearbyTime;
                }
                if (performanceData.gAffectCalcTime > performanceData.gAffectCalcTimeMax){
                    performanceData.gAffectCalcTimeMax = performanceData.gAffectCalcTime;
                }
                if (performanceData.positionUpdateTime > performanceData.positionUpdateTimeMax){
                    performanceData.positionUpdateTimeMax = performanceData.positionUpdateTime;
                }
                if (performanceData.ParticleAffcetCalcTime > performanceData.ParticleAffcetCalcTimeMax){
                    performanceData.ParticleAffcetCalcTimeMax = performanceData.ParticleAffcetCalcTime;
                }
                performanceData.totalTimeAll.push(performanceData.totalTime);
                performanceData.gridResetTimeAll.push(performanceData.gridResetTime);
                performanceData.getNearbyTimeAll.push(performanceData.getNearbyTime);
                performanceData.gAffectCalcTimeAll.push(performanceData.gAffectCalcTime);
                performanceData.positionUpdateTimeAll.push(performanceData.positionUpdateTime);
                performanceData.ParticleAffcetCalcTimeAll.push(performanceData.ParticleAffcetCalcTime);
                // æ›´æ–°æ€§èƒ½æ•¸æ“šé¡¯ç¤º
                document.getElementById('total-time').textContent = performanceData.totalTime.toFixed(2);
                if (performance.now() - totalTimeAverageUpdateLastTime >= totalTimeAverageUpdateMs) {
                    performanceData.totalTimeAverage = performanceData.totalTimeAll.reduce((a, b) => a + b, 0) / performanceData.totalTimeAll.length;
                    document.getElementById('total-time-average').textContent = performanceData.totalTimeAverage.toFixed(2);
                    performanceData.totalTimeAll = [];  
                    totalTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('total-time-max').textContent = performanceData.totalTimeMax.toFixed(2);
                
                document.getElementById('grid-reset-time').textContent = performanceData.gridResetTime.toFixed(2);  
                if (performance.now() - gridResetTimeAverageUpdateLastTime >= gridResetTimeAverageUpdateMs) {
                    performanceData.gridResetTimeAverage = performanceData.gridResetTimeAll.reduce((a, b) => a + b, 0) / performanceData.gridResetTimeAll.length;
                    document.getElementById('grid-reset-time-average').textContent = performanceData.gridResetTimeAverage.toFixed(2);
                    performanceData.gridResetTimeAll = [];
                    gridResetTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('grid-reset-time-max').textContent = performanceData.gridResetTimeMax.toFixed(2);
                document.getElementById('grid-reset-time-single-average').textContent = (performanceData.gridResetTimeAverage/gameState.particleTypes).toFixed(2);
                document.getElementById('grid-reset-time-run-per-update').textContent = gameState.particleTypes;

                document.getElementById('get-nearby-time').textContent = performanceData.getNearbyTime.toFixed(2);
                if (performance.now() - getNearbyTimeAverageUpdateLastTime >= getNearbyTimeAverageUpdateMs) {
                    performanceData.getNearbyTimeAverage = performanceData.getNearbyTimeAll.reduce((a, b) => a + b, 0) / performanceData.getNearbyTimeAll.length;
                    document.getElementById('get-nearby-time-average').textContent = performanceData.getNearbyTimeAverage.toFixed(2);
                    performanceData.getNearbyTimeAll = [];
                    getNearbyTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('get-nearby-time-max').textContent = performanceData.getNearbyTimeMax.toFixed(2);
                document.getElementById('get-nearby-time-single-average').textContent = (performanceData.getNearbyTimeAverage/(gameState.particleTypes*particles.length)).toFixed(2);
                document.getElementById('get-nearby-time-run-per-update').textContent = gameState.particleTypes*particles.length;

                document.getElementById('g-Affect-Calc-time').textContent = performanceData.gAffectCalcTime.toFixed(2);
                if (performance.now() - gAffectCalcTimeAverageUpdateLastTime >= gAffectCalcTimeAverageUpdateMs) {
                    performanceData.gAffectCalcTimeAverage = performanceData.gAffectCalcTimeAll.reduce((a, b) => a + b, 0) / performanceData.gAffectCalcTimeAll.length;
                    document.getElementById('g-Affect-Calc-time-average').textContent = performanceData.gAffectCalcTimeAverage.toFixed(2);
                    performanceData.gAffectCalcTimeAll = [];
                    gAffectCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('g-Affect-Calc-time-max').textContent = performanceData.gAffectCalcTimeMax.toFixed(2);
                document.getElementById('g-Affect-Calc-time-single-average').textContent = (performanceData.gAffectCalcTimeAverage/(gameState.particleTypes*particles.length)).toFixed(2);
                document.getElementById('g-Affect-Calc-time-run-per-update').textContent = gameState.particleTypes*particles.length;
                
                document.getElementById('position-update-time').textContent = performanceData.positionUpdateTime.toFixed(2);
                if (performance.now() - positionUpdateTimeAverageUpdateLastTime >= positionUpdateTimeAverageUpdateMs) {
                    performanceData.positionUpdateTimeAverage = performanceData.positionUpdateTimeAll.reduce((a, b) => a + b, 0) / performanceData.positionUpdateTimeAll.length;
                    document.getElementById('position-update-time-average').textContent = performanceData.positionUpdateTimeAverage.toFixed(2);
                    performanceData.positionUpdateTimeAll = [];
                    positionUpdateTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('position-update-time-max').textContent = performanceData.positionUpdateTimeMax.toFixed(2);
                document.getElementById('position-update-time-single-average').textContent = (performanceData.positionUpdateTimeAverage/particles.length).toFixed(2);
                document.getElementById('position-update-time-run-per-update').textContent = particles.length

                document.getElementById('Particle-Affect-Calc-time').textContent = performanceData.ParticleAffcetCalcTime.toFixed(2);
                if (performance.now() - ParticleAffcetCalcTimeAverageUpdateLastTime >= ParticleAffcetCalcTimeAverageUpdateMs) {
                    performanceData.ParticleAffcetCalcTimeAverage = performanceData.ParticleAffcetCalcTimeAll.reduce((a, b) => a + b, 0) / performanceData.ParticleAffcetCalcTimeAll.length;
                    document.getElementById('Particle-Affect-Calc-time-average').textContent = performanceData.ParticleAffcetCalcTimeAverage.toFixed(2);
                    performanceData.ParticleAffcetCalcTimeAll = [];
                    ParticleAffcetCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('Particle-Affect-Calc-time-max').textContent = performanceData.ParticleAffcetCalcTimeMax.toFixed(2);

                // æ›´æ–°é¸ä¸­ç²’å­çš„å±¬æ€§é¡¯ç¤º
                if (gameState.enableParticleAffcetRadiusShow){
                    const propertyElement = document.getElementById('selectedParticleProperty');
                    if (gameState.selectedParticleId !== null && particles.length > 0) {
                        const selectedParticle = particles.find(p => p.id === gameState.selectedParticleId);
                        if (selectedParticle) {
                            const properties = [
                                `\n`,
                                `é¡å‹: ${selectedParticle.type + 1}`,
                                `ä½ç½®: (${selectedParticle.x.toFixed(2)}, ${selectedParticle.y.toFixed(2)})`,
                                `é€Ÿåº¦: (${selectedParticle.vx.toFixed(2)}, ${selectedParticle.vy.toFixed(2)})`,
                                `é¡è‰²: ${selectedParticle.color}`,
                                `æ˜¯å¦åœ¨é‚Šç•Œå¤–: ${selectedParticle.isOutside ? 'æ˜¯' : 'å¦'}`
                            ];
                            propertyElement.innerHTML = properties.join('<br>');
                        } else {
                            propertyElement.textContent = 'æ‰¾ä¸åˆ°é¸ä¸­çš„ç²’å­';
                        }
                    } else {
                        propertyElement.textContent = 'æœªé¸ä¸­ç²’å­';
                    }
                }

                // è¨ˆç®—ä¸¦é¡¯ç¤º FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    document.getElementById('fps').textContent = fps;
                    frameCount = 0;
                    lastTime = currentTime;
                }
                gameUPS = (1000 / (performanceData.totalTimeAverage)).toFixed(0);
                document.getElementById('gameUPS').textContent = gameUPS;
                requestAnimationFrame(() => {
                    worker.postMessage({ type: 'canUpdate' });
                    update();
                });
            }

            // æ¥æ”¶ä¾†è‡ª Worker çš„æ¶ˆæ¯
            worker.onmessage = function (e) {
                if (e.data.type === 'update') {
                    particles = e.data.particles;
                    particleGroups = e.data.particleGroups;
                    gameState.gridData.nearbyCells = e.data.nearbyCells;
                    gameState.gridData.width = e.data.gridDataWidth;
                    gameState.gridData.height = e.data.gridDataHeight;
                    performanceData.totalTime = e.data.performanceData.totalTime;
                    performanceData.gridResetTime = e.data.performanceData.gridResetTime
                    performanceData.getNearbyTime = e.data.performanceData.getNearbyTime
                    performanceData.gAffectCalcTime = e.data.performanceData.gAffectCalcTime;
                    performanceData.positionUpdateTime = e.data.performanceData.positionUpdateTime;
                    performanceData.ParticleAffcetCalcTime = e.data.performanceData.ParticleAffcetCalcTime;
                    if (gameState.enableParticleAffcetRadiusShow){
                        gameState.nearbyParticlesList = e.data.nearbyParticlesList;
                        for (let i = 0; i < gameState.nearbyParticlesList.length; i++) {
                            //console.log(`gameState.nearbyParticlesList[${i}]: ${gameState.nearbyParticlesList[i]}`);
                            document.getElementById(`particle-nearby-particles-${i}`).textContent = `ç¯„åœå…§çš„é¡å‹${i + 1}ç²’å­æ•¸é‡: ${gameState.nearbyParticlesList[i] ? gameState.nearbyParticlesList[i].length : 0}`;
                        }
                    }

                    // æ›´æ–°ç¶²æ ¼å¯¬åº¦å’Œé«˜åº¦çš„é¡¯ç¤º
                    document.getElementById('grid-width').textContent = gameState.gridData.width;
                    document.getElementById('grid-height').textContent = gameState.gridData.height;
                }
            };

            // æ›´æ–°è¦å‰‡
            function updateRules() {
                // ä½¿ç”¨ gameState ä¸­çš„çŸ©é™£æ•¸æ“š
                worker.postMessage({
                    type: 'updateRules',
                    forceMatrix: gameState.forceMatrix,
                    distanceMatrix: gameState.distanceMatrix
                });
            }

            
            

            // éš¨æ©ŸåŒ–å€¼
            function randomizeValues() {
                document.querySelectorAll('.particle-force').forEach(p => {
                    const value = (Math.random() * 2 - 1).toFixed(1);
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                document.querySelectorAll('.particle-distance').forEach(p => {
                    const value = Math.floor(Math.random() * (300 - 10 + 1)) + 10;
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                updateRules();
            }

            // éš¨æ©ŸåŒ–ä¸¦é‡æ–°é–‹å§‹
            function randomizeAndRestart() {
                randomizeValues();
                initGame();
            }

            // æ§åˆ¶æ¿åˆ‡æ›
            const toggleButton = document.getElementById('toggle-controls');
            const controlPanel = document.getElementById('controls');

            toggleButton.addEventListener('click', () => {
                controlPanel.classList.toggle('visible');
                if (controlPanel.classList.contains('visible')) {
                    toggleButton.style.right = '310px';
                    toggleButton.textContent = 'âœ•';
                } else {
                    toggleButton.style.right = '10px';
                    toggleButton.textContent = 'â˜°';
                }
                updateCanvasSize();
            });

            // è‡ªå‹•éš±è—åˆ‡æ›æŒ‰éˆ•
            let hideTimeout;
            document.addEventListener('mousemove', () => {
                toggleButton.style.opacity = '0.5';
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    toggleButton.style.opacity = '0';
                }, 3000);
            });

            // åŒ¯å‡ºè¦å‰‡
            function exportRules() {
                const rules = {};
                // æ·»åŠ è¦å‰‡
                rules['force'] = gameState.forceMatrix;
                rules['distance'] = gameState.distanceMatrix;
                // æ·»åŠ ç²’å­æ•¸é‡
                rules['particleCounts'] = gameState.particleCounts;
                // æ·»åŠ ç²’å­é¡å‹
                rules['particleTypes'] = gameState.particleTypes;
                // æ·»åŠ ç²’å­é¡è‰²
                rules['particleColors'] = gameState.particleColors;
                // æ·»åŠ ç©¿é€æ¨¡å¼ç‹€æ…‹
                rules['isThrough'] = document.getElementById('isThrough').checked;
                rules['tHalf'] = gameState.tHalf;
                rules['dt'] = gameState.dt;
                rules['mouseForce'] = gameState.mouseForce;
                rules['gridData'] = gameState.gridData;

                // æ·»åŠ é¡è‰²
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(rules));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "particle_rules.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            // å°å…¥è¦å‰‡
            function importRules(shouldRestart) {
                const fileInput = document.getElementById('import-file');
                fileInput.value = '';
                fileInput.dataset.shouldRestart = shouldRestart;
                fileInput.click();
            }

            function handleFileSelect(event) {
                const file = event.target.files[0];
                const shouldRestart = event.target.dataset.shouldRestart === 'true';
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const rules = JSON.parse(e.target.result);
                        Object.keys(rules).forEach(id => {
                            if (id === 'isThrough') {
                                // è¨­ç½®ç©¿é€æ¨¡å¼ç‹€æ…‹
                                const throughCheckbox = document.getElementById('isThrough');
                                throughCheckbox.checked = rules[id];
                                throughCheckbox.dispatchEvent(new Event('change'));
                            } else if (id === 'particleCounts') {
                                gameState.particleCounts = rules[id];
                            } else if (id === 'particleTypes') {
                                gameState.particleTypes = rules[id];
                            } else if (id === 'particleColors') {
                                gameState.particleColors = rules[id];
                            } else if (id === 'tHalf') {
                                gameState.tHalf = rules[id];
                            } else if (id === 'dt') {
                                gameState.dt = rules[id];
                            } else if (id === 'mouseForce') {
                                gameState.mouseForce = rules[id];
                            } else if (id === 'gridData') {
                                gameState.gridData = rules[id];
                            } else if (id === 'forceMatrix') {
                                gameState.forceMatrix = rules[id];
                            } else if (id === 'distanceMatrix') {
                                gameState.distanceMatrix = rules[id];
                            }
                            updateHTML();
                        });
                        updateRules();
                        if (shouldRestart) {
                            setTimeout(initGame, 100);
                        }
                    };
                    reader.readAsText(file);
                }
            }

            // æ›´æ–°é¡è‰²
            function updateColors() {
                //console.log(`index.html: gameState.particleColors: ${gameState.particleColors}`);
                worker.postMessage({
                    type: 'updateColors',
                    particleColors: gameState.particleColors
                });
            }

            // ç‚ºåŒ¯å‡ºè¦å‰‡æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('export-rules').addEventListener('click', exportRules);
            // ç‚ºå°å…¥è¦å‰‡æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('import-rules').addEventListener('click', () => importRules(false));
            // ç‚ºå°å…¥è¦å‰‡ä¸¦é‡æ–°é–‹å§‹æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('import-rules-and-restart').addEventListener('click', () => importRules(true));
            // ç‚ºå°å…¥æ–‡ä»¶æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('import-file').addEventListener('change', handleFileSelect);

            let mouseX = 0;
            let mouseY = 0;
            let isMouseDown = false;
            let isUpdateMouse = false;
            let isUpdateMouseDownUp = false;

            // ç©¿é€æ¨¡å¼åˆ‡æ›
            const throughCheckbox = document.getElementById("isThrough");
            throughCheckbox.addEventListener('change', () => {
                worker.postMessage({ type: 'setThrough', isThrough: throughCheckbox.checked });
            });
            
            // æ·»åŠ æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
            document.getElementById('randomize-button').addEventListener('click', randomizeValues);
            document.getElementById('restart-button').addEventListener('click', initGame);
            document.getElementById('randomize-and-restart-button').addEventListener('click', randomizeAndRestart);
            document.addEventListener("keydown", function(event) {
                if (event.key === "r") {
                    randomizeValues();
                }
                if (event.key === "s") {
                    initGame();
                }
                if (event.key === "f") {
                    randomizeAndRestart();
                }
                if (event.key === "x") {
                    isUpdateMouseDownUp = false;
                }
                if (event.key === "m") {
                    isUpdateMouse = false;
                }
                if (event.key === "t") {
                    throughCheckbox.checked = !throughCheckbox.checked;
                    throughCheckbox.dispatchEvent(new Event('change'));
                }
            });

            // æ·»åŠ æ»‘é¼ äº‹ä»¶ç›£è½å™¨
            canvas2d.addEventListener('mousedown', (e) => {
                if (!gameState.enableParticleAffcetRadiusShow){
                    isUpdateMouseDownUp = true;
                    isUpdateMouse = true;
                    isMouseDown = true;
                    updateMousePosition(e);
                }
            });

            canvas2d.addEventListener('mouseup', () => {
                if (isUpdateMouseDownUp) {
                    isMouseDown = false;
                    worker.postMessage({ type: 'setMouseInactive' });
                }
            });

            canvas2d.addEventListener('mousemove', (e) => {
                if (isUpdateMouse) {
                    updateMousePosition(e);
                }
            });

            function updateMousePosition(e) {
                const rect = canvas2d.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                if (isMouseDown) {
                    worker.postMessage({ type: 'updateMousePosition', x: mouseX, y: mouseY });
                }
            }

            function updateMouseForce(){
                worker.postMessage({ type: 'updateMouseForce', force: gameState.mouseForce });
            }
            function updateCellSize(){
                worker.postMessage({ type: 'updateCellSize', size: gameState.gridData.cellSize });
            }
            function updateSetectGridDistance(){
                worker.postMessage({ type: 'updateSetectGridDistance', distance: gameState.setectGridDistance });
            }
            function updateUpdateInterval(){
                worker.postMessage({ type: 'updateUpdateInterval', interval: gameState.updateInterval });
            }
            function updateDt(){
                worker.postMessage({ type: 'updateDt', dt: gameState.dt });
            }
            function updateBallRadius(){
                worker.postMessage({ type: 'updateBallRadius', ballRadius: gameState.ballRadius });
            }
            function updateRadiusShow(){
                worker.postMessage({ type: 'updateRadiusShow', RadiusShow: gameState.RadiusShow });
            }
            function updateTHalf(){
                worker.postMessage({ type: 'updateTHalf', tHalf: gameState.tHalf });
            }
            function updateEveryThing(){
                updateRules();
                updateColors();
                updateMouseForce();
                updateCellSize();
                updateSetectGridDistance();
                updateUpdateInterval();
                updateBallRadius();
                updateRadiusShow();
                updateTHalf();
                updateDt();
            }

            // ç‚ºæ»‘é¼ åŠ›é‡æ»‘å¡Šæ·»åŠ äº‹ä»¶ç›£è½å™¨
            const mouseForceSlider = document.getElementById('mouse-force');
            const mouseForceNumber = document.getElementById('mouse-force-number');
            mouseForceSlider.addEventListener('input', () => {
                mouseForceNumber.value = mouseForceSlider.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceSlider.value) });
            });
            mouseForceNumber.addEventListener('input', () => {
                mouseForceSlider.value = mouseForceNumber.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceNumber.value) });
            });

            // ç‚ºç¶²æ ¼å¤§å°æ»‘å¡Šæ·»åŠ äº‹ä»¶ç›£è½å™¨
            const cellSizeSlider = document.getElementById('cell-size');
            const cellSizeNumber = document.getElementById('cell-size-number');
            cellSizeSlider.addEventListener('input', () => {
                cellSizeNumber.value = cellSizeSlider.value;
                gameState.gridData.cellSize = parseInt(cellSizeSlider.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeSlider.value) });
            }); 
            cellSizeNumber.addEventListener('input', () => {
                cellSizeSlider.value = cellSizeNumber.value;
                gameState.gridData.cellSize = parseInt(cellSizeNumber.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeNumber.value) });
            });

            // ç‚ºé¸ä¸­ç¶²æ ¼è·é›¢æ»‘å¡Šæ·»åŠ äº‹ä»¶ç›£è½å™¨
            const setectGridDistanceSlider = document.getElementById('setectGridDistance');
            const setectGridDistanceNumber = document.getElementById('setectGridDistance-number');
            setectGridDistanceSlider.addEventListener('input', () => {
                setectGridDistanceNumber.value = setectGridDistanceSlider.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceSlider.value) });
            });
            setectGridDistanceNumber.addEventListener('input', () => {
                setectGridDistanceSlider.value = setectGridDistanceNumber.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceNumber.value) });
            })

            // ç‚ºæ›´æ–°é–“éš”æ»‘å¡Šæ·»åŠ äº‹ä»¶ç›£è½å™¨
            const updateIntervalSlider = document.getElementById('updateInterval');
            const updateIntervalNumber = document.getElementById('updateInterval-number');
            const updateIntervalUnit = document.getElementById('updateInterval-unit');
            updateIntervalSlider.addEventListener('input', () => {
                updateIntervalNumber.value = updateIntervalSlider.value;
                updateIntervalUnit.selectedIndex = [...updateIntervalUnit.options].reduce((closest, option) => {
                    const distance = Math.abs(option.value - updateIntervalSlider.value);
                    return (distance < closest.distance) ? {option: option, distance: distance} : closest;
                }, {option: null, distance: Infinity}).option.index;
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalSlider.value) });
            });
            updateIntervalNumber.addEventListener('input', () => {
                updateIntervalSlider.value = updateIntervalNumber.value;
                updateIntervalUnit.selectedIndex = [...updateIntervalUnit.options].reduce((closest, option) => {
                    const distance = Math.abs(option.value - updateIntervalNumber.value);
                    return (distance < closest.distance) ? {option: option, distance: distance} : closest;
                }, {option: null, distance: Infinity}).option.index;
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalNumber.value) });
            }); 
            updateIntervalUnit.addEventListener('change', () => {
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalUnit.value) });
                updateIntervalSlider.value = updateIntervalUnit.value;
                updateIntervalNumber.value = updateIntervalUnit.value;
            });

            // æ·»åŠ t_halfæ§åˆ¶äº‹ä»¶ç›£è½å™¨
            document.getElementById('t-half').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half-number').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });

            document.getElementById('t-half-number').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });
            
            // æ·»åŠ ç¶²æ ¼é¡¯ç¤ºåˆ‡æ›
            const showGridCheckbox = document.getElementById('showGrid');
            showGridCheckbox.addEventListener('change', () => {
                gameState.showGrid = showGridCheckbox.checked;
                worker.postMessage({ type: 'toggleGrid', show: gameState.showGrid });
            });

            const enableParticleAffcetRadiusShowCheckbox = document.getElementById('enableParticleAffcetRadiusShow');
            enableParticleAffcetRadiusShowCheckbox.addEventListener('change', () => {
                gameState.enableParticleAffcetRadiusShow = enableParticleAffcetRadiusShowCheckbox.checked;
                worker.postMessage({ type: 'toggleParticleAffcetRadiusShow', enable: gameState.enableParticleAffcetRadiusShow });
            });

            /*
            const isOneRadiusShowCheckbox = document.getElementById('isOneRadiusShow');
            isOneRadiusShowCheckbox.addEventListener('change', () => {
                isOneRadiusShow = isOneRadiusShowCheckbox.checked;
            });
            const isTwoRadiusShowCheckbox = document.getElementById('isTwoRadiusShow');
            isTwoRadiusShowCheckbox.addEventListener('change', () => {
                isTwoRadiusShow = isTwoRadiusShowCheckbox.checked;
            });
            const isThreeRadiusShowCheckbox = document.getElementById('isThreeRadiusShow');
            isThreeRadiusShowCheckbox.addEventListener('change', () => {
                isThreeRadiusShow = isThreeRadiusShowCheckbox.checked;
            });
            */
           
            function initializeMatrices(types, oldForceMatrix, oldDistanceMatrix) {
                forceMatrix = [];
                for (let i = 0; i < types; i++) {
                    forceMatrix.push([]);
                    for (let j = 0; j < types; j++) {
                        // Keep old force value if available, otherwise use 0
                        forceMatrix[i].push(oldForceMatrix && i < oldForceMatrix.length && j < oldForceMatrix[i].length ? 
                            oldForceMatrix[i][j] : Math.random()*2-1);
                    }
                }
                gameState.forceMatrix = forceMatrix;
                //console.log(`index.html: forceMatrix: ${forceMatrix}`);
                
                distanceMatrix = [];
                for (let i = 0; i < types; i++) {
                    distanceMatrix.push([]);
                    for (let j = 0; j < types; j++) {
                        // Keep old distance value if available, otherwise use 100
                        distanceMatrix[i].push(oldDistanceMatrix && i < oldDistanceMatrix.length && j < oldDistanceMatrix[i].length ?
                            oldDistanceMatrix[i][j] : 150);
                    }
                }
                gameState.distanceMatrix = distanceMatrix;
                //console.log(`index.html: distanceMatrix: ${distanceMatrix}`);
                
                particleGroups = [];
                for (let i = 0; i < types; i++) {
                    particleGroups.push([]);
                }
                gameState.particleGroups = particleGroups;
                //console.log(`index.html: particleGroups: ${particleGroups}`);
            }
            function initializeColors(types) {
                particleColors = [];
                for (let i = 0; i < types; i++) {
                    particleColors.push(`hsl(${i * 360 / types}, 100%, 50%)`);
                }
                gameState.particleColors = particleColors;
            }
            function initializeParticleCounts(types) {
                particleCounts = [];
                for (let i = 0; i < types; i++) {
                    particleCounts.push(gameState.particleCounts[i] || 250);
                }
                gameState.particleCounts = particleCounts;
            }
            // æ·»åŠ ç²’å­é¡å‹æ•¸é‡ç›£è½å™¨
            document.getElementById('particle-types').addEventListener('input', (e) => {
                const types = parseInt(e.target.value);
                gameState.particleTypes = types;
                initializeColors(types);
                initializeMatrices(types, gameState.forceMatrix, gameState.distanceMatrix);
                initializeParticleCounts(types);
                updateParticleSystem();
                updateEveryThing();
                initGame();
            });

            // ä¿®æ”¹å–®å…ƒæ ¼é¸æ“‡åŠŸèƒ½
            canvas2d.addEventListener('click', (e) => {
                if (gameState.showGrid) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const cellX = Math.floor(x / gameState.gridData.cellSize);
                    const cellY = Math.floor(y / gameState.gridData.cellSize);
                    gameState.gridData.selectedCell = { x: cellX, y: cellY };
                    worker.postMessage({ 
                        type: 'selectCell', 
                        cell: gameState.gridData.selectedCell,
                    });
                    
                    // ç›´æ¥æ›´æ–°é¡¯ç¤ºï¼Œä»¥æä¾›å³æ™‚åé¥‹
                    document.getElementById('selected-cell').textContent = `x: ${cellX}, y: ${cellY}`;
                }
                
                if (gameState.enableParticleAffcetRadiusShow) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // æ‰¾åˆ°æœ€è¿‘çš„ç²’å­
                    selectedParticle = particles.reduce((closest, particle) => {
                        const dx = particle.x - x;
                        const dy = particle.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return (distance < closest.distance)&&(distance < 10) ? { particle, distance } : closest;
                    }, { particle: null, distance: Infinity }).particle;
                    if (selectedParticle) {
                        gameState.selectedParticleId = selectedParticle.id;
                        gameState.selectedParticleType = selectedParticle.type;
                        document.getElementById('selectedParticleId').textContent = gameState.selectedParticleId;
                        // è«‹æ±‚ worker è¨ˆç®—é™„è¿‘çš„ç²’å­
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: gameState.selectedParticleId,
                        });
                    } else {
                        document.getElementById('selectedParticleId').textContent = 'ç„¡';
                        gameState.selectedParticleId = null;
                        gameState.selectedParticleType = null;
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: null,
                        });
                        gameState.nearbyParticlesList = [];
                    }
                }
            });

            // åˆå§‹åŒ–éŠæˆ²ä¸¦é–‹å§‹æ›´æ–°å¾ªç’°
            updateParticleSystem();
            updateEveryThing();
            initGame();
            update();

            // å‰µå»ºç²’å­é¡å‹æ§åˆ¶ç•Œé¢
            function createParticleTypeControls(type, total, min, max, step, count) {
                const defaultColor = gameState.particleColors[type];
                
                return `
                    <div class="particle-type" data-type="${type}">
                        <h4>é¡å‹ ${type + 1}</h4>
                        <div>
                            <label>æ•¸é‡:</label>
                            <input type="range" class="particle-count" min="${min}" max="${max}" step="${step}" value="${count}">
                            <input type="number" class="particle-count-number" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${count}">
                        </div>
                        <div>
                            <label>é¡è‰²:</label>
                            <div class="color-inputs">
                                <input type="color" class="particle-color" value="${hslToHex(defaultColor)}">
                                <span class="hsl-display">${defaultColor}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            function createMatrixTable(types, matrixType, min, max, step, matrix){
                let html = '<table class="matrix-container">';
                for (let i = 0; i < types; i++) {
                    html += `<tr>`;
                    for (let j = 0; j < types; j++) {
                        html += `<td><input type="number" class="matrix-input ${matrixType}" data-i="${i}" data-j="${j}" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${matrix[i][j]}"></td>`;
                    }
                    html += `</tr>`;
                }
                html += '</table>';
                return html;
            }

            // æ›´æ–°ç²’å­ç³»çµ±
            function updateParticleSystem() {
                const types = gameState.particleTypes;
                const particleSettings = document.getElementById('particle-settings');
                const interactionMatrix = document.getElementById('interaction-matrix');
                const particleAffcetRadiusShow = document.getElementById('particle-affcet-radius-show');
                const particleNearbyParticles = document.getElementById('particle-nearby-particles');
                for (let i = 0; i < types; i++) {
                    gameState.RadiusShow[i] = gameState.RadiusShow[i] || true;
                };
                
                // æ›´æ–°ç²’å­é¡å‹æ§åˆ¶
                particleSettings.innerHTML = '';
                for (let i = 0; i < types; i++) {
                    particleSettings.innerHTML += createParticleTypeControls(i, types, 0, 500, 10, gameState.particleCounts[i]);
                }
                
                // æ›´æ–°äº¤äº’çŸ©é™£
                interactionMatrix.innerHTML = `
                    <div class="matrix-table">  
                        <h4>ç²’å­å¼•åŠ›</h4>
                        <p class="description">æ•¸å€¼è¶Šå¤§ï¼Œç²’å­è¶Šå®¹æ˜“èšé›†åœ¨ä¸€èµ·</p>
                        ${createMatrixTable(types, 'particle-force', -1, 1, 0.05, gameState.forceMatrix)}
                    </div>

                    <div class="matrix-table">
                        <h4>ç²’å­è·é›¢</h4>
                        <p class="description">æ•¸å€¼è¶Šå¤§ï¼Œå¼•åŠ›èŒƒåœè¶Šå¤§</p>
                        ${createMatrixTable(types, 'particle-distance', 10, 300, 10, gameState.distanceMatrix)}
                    </div>
                `;
                
                particleAffcetRadiusShow.innerHTML = '';
                
                for (let i = 0; i < types; i++) {
                    particleAffcetRadiusShow.innerHTML += `
                        <div class="particle-affcet-radius-show">
                            <label for="show-particle-affcet-radius-${i}">é¡¯ç¤ºé¡å‹${i + 1}ç²’å­å½±éŸ¿ç¯„åœ</label>
                            <input type="checkbox" class="show-particle-affcet-radius" id="show-particle-affcet-radius-${i}" data-type="${i}" checked>
                        </div>
                    `;
                }
                particleNearbyParticles.innerHTML = "";
                for (let i = 0; i < types; i++) {
                    particleNearbyParticles.innerHTML += `
                        <p class="particle-nearby-particles" id="particle-nearby-particles-${i}">ç¯„åœå…§çš„é¡å‹${i + 1}ç²’å­æ•¸é‡: N/A</p>
                    `;
                }
                
                // æ·»åŠ äº‹ä»¶ç›£è½å™¨
                setupParticleControlEventListeners();
                setupMatrixEventListeners();
                setupParticleAffcetRadiusShowEventListeners();
                // é‡æ–°åˆå§‹åŒ–ç²’å­ç³»çµ±
                initGame();
            }
            // è¨­ç½®ç²’å­æ§åˆ¶çš„äº‹ä»¶ç›£è½å™¨
            function setupParticleControlEventListeners() {
                // æ•¸é‡æ§åˆ¶
                document.querySelectorAll('.particle-count').forEach(input => {
                    const numberInput = input.parentElement.querySelector('.particle-count-number');
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    
                    input.addEventListener('input', (e) => {
                        const value = e.target.value;
                        numberInput.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                    
                    numberInput.addEventListener('input', (e) => {
                        const value = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        input.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                });

                // é¡è‰²æ§åˆ¶
                document.querySelectorAll('.particle-color').forEach(input => {
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    const hslDisplay = input.parentElement.querySelector('.hsl-display');
                    
                    input.addEventListener('input', (e) => {
                        const hsl = hexToHsl(e.target.value);
                        gameState.particleColors[type] = hsl;
                        hslDisplay.textContent = hsl;
                        worker.postMessage({
                            type: 'updateColors',
                            particleColors: gameState.particleColors
                        });
                    });
                });
            }
            // è¨­ç½®çŸ©é™£è¼¸å…¥çš„äº‹ä»¶ç›£è½å™¨
            function setupMatrixEventListeners() {
                document.querySelectorAll('.particle-force').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const force = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        gameState.forceMatrix[i][j] = parseFloat(force);
                        updateRules();
                    });
                });

                document.querySelectorAll('.particle-distance').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        const distance = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        gameState.distanceMatrix[i][j] = parseFloat(distance);
                        updateRules();
                    });
                });
            }
            // è¨­ç½®ç²’å­å½±éŸ¿ç¯„åœé¡¯ç¤ºçš„äº‹ä»¶ç›£è½å™¨
            function setupParticleAffcetRadiusShowEventListeners() {
                document.querySelectorAll('.show-particle-affcet-radius').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const type = parseInt(e.target.dataset.type);
                        gameState.RadiusShow[type] = e.target.checked;
                        worker.postMessage({
                            type: 'updateRadiusShow',
                            RadiusShow: gameState.RadiusShow
                        });
                    });
                });
            }

            // HSL è½‰ Hex é¡è‰²å‡½æ•¸
            function hslToHex(hsl) {
                const match = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!match) return '#000000';
                
                const h = parseInt(match[1]) / 360;
                const s = parseInt(match[2]) / 100;
                const l = parseInt(match[3]) / 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            // Hex è½‰ HSL é¡è‰²å‡½æ•¸
            function hexToHsl(hex) {
                // ç§»é™¤ # è™Ÿï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                hex = hex.replace(/^#/, '');
                
                // è§£æ RGB å€¼
                const bigint = parseInt(hex, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                
                // è½‰æ›ç‚º 0-1 ç¯„åœ
                const rr = r / 255;
                const gg = g / 255;
                const bb = b / 255;
                
                const max = Math.max(rr, gg, bb);
                const min = Math.min(rr, gg, bb);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case rr: h = (gg - bb) / d + (gg < bb ? 6 : 0); break;
                        case gg: h = (bb - rr) / d + 2; break;
                        case bb: h = (rr - gg) / d + 4; break;
                    }
                    
                    h /= 6;
                }
                
                return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
            }
        });
    </script>
</body>

</html>
