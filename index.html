<!--
 * Copyright (c) 2024 OneNok_HK
 * Licensed under the MIT License. See LICENSE file in the project root for full license information.
-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>particles life</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            background-color: black;
        }

        #controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            transition: right 0.3s ease-in-out;
            z-index: 1000;
        }

        #controls > div:not(#controls > div > div) {
            margin-top: 20px;
        }

        #controls.visible {
            right: 0;
        }

        #toggle-controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.7);
            transition: right 0.3s ease-in-out, opacity 0.3s ease;
            opacity: 0;
        }

        #toggle-controls:hover {
            opacity: 1;
        }

        /*canvas {
            border: 1px solid;
            border-color: rgb(63, 63, 63);
        }*/

        /* ÊåâÈàïÁµÑÊ®£Âºè */
        .button-group {
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        h3 {
            color: #272727;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .button-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .styled-button {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            border: none;
            padding: 10px 20px;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .styled-button:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .styled-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* ÊÄßËÉΩÊï∏ÊìöÈ°ØÁ§∫ÂçÄÂüüÊ®£Âºè */
        #performance-data {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        #performance-data h3 {
            color: #fff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #performance-data p {
            color: #ffffff;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        #performance-data span {
            color: #5dff62;
            font-weight: bold;
        }

        /* ÊéßÂà∂ÂÖÉÁ¥†Ê®£Âºè */
        input[type="range"] {
            width: 200px;
            height: 5px;
            border-radius: 5px;
            background: #4d4d4d;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
            background: #6e6e6e;
        }

        input[type="number"] {
            width: 70px;
            padding: 2px 5px;
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            font-size: 13px;
            height: 20px;
            box-sizing: border-box;
            margin-top: 5px;
        }

        input[type="number"]:focus,
        select:focus {
            border-color: #6e6e6e;
            outline: none;
            box-shadow: 0 0 5px rgba(110, 110, 110, 0.5);
        }

        select {
            padding: 2px 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            color: #ffffff;
            font-size: 13px;
            height: 20px;
        }

        /* Ê®ôÁ±§Ê®£Âºè */
        label {
            color: #d0d0d0;
            margin-right: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Ë§áÈÅ∏Ê°ÜÊ®£Âºè */
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 10px;
        }

        /* ‰∏ÄËà¨Ê®ôÁ±§ÂíåÊñáÂ≠óÁöÑÈªòË™çÈ°èËâ≤ */
        label {
            color: #2e2e2e;
        }

        /* ‰∏ÄËà¨ÊÆµËêΩÊñáÂ≠ó */
        p {
            color: #2e2e2e;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* ÊúâÁâπÂÆöËÉåÊôØÁöÑÂÖÉÁ¥†‰øùÊåÅÁôΩËâ≤ÊñáÂ≠ó */
        #performance-data p {
            color: #ffffff;
        }

        /* ‰øùÊåÅÊåâÈàïÊñáÂ≠óÁÇ∫ÁôΩËâ≤ÔºåÂõ†ÁÇ∫ÊåâÈàïÊúâÊ∑±Ëâ≤ËÉåÊôØ */
        .styled-button {
            color: #d0d0d0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* ÊÄßËÉΩÊï∏ÊìöÂçÄÂüü‰øùÊåÅÁôΩËâ≤ÊñáÂ≠ó */
        #performance-data h3,
        #performance-data p {
            color: #ffffff;
        }

        /* ÊÄßËÉΩÊï∏Êìö‰∏≠ÁöÑÊï∏ÂÄº‰øùÊåÅÁ∂†Ëâ≤ */
        #performance-data span {
            color: #5dff62;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* ÂàáÊèõÈñãÈóúÂÆπÂô® */
        .toggle-container {
            margin: 10px 0;
            display: flex;
        }

        /* Ê®ôÁ±§Ê®£Âºè */
        .toggle-label {
            width: fit-content;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            pointer-events: none;
        }

        /* ÂàáÊèõÈñãÈóúÂ§ñËßÄ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        /* Èö±ËóèÂéüÂßãË§áÈÅ∏Ê°ÜÔºå‰ΩÜ‰øùÊåÅÂú®ÊªëÂ°ä‰ΩçÁΩÆ */
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1; /* Á¢∫‰øùË§áÈÅ∏Ê°ÜÂú®ÊúÄ‰∏äÂ±§ */
            margin: 0; /* ÁßªÈô§ÈªòË™çÈÇäË∑ù */
        }

        /* ÊªëÂ°äÊ®£Âºè */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4d4d4d;
            transition: .3s;
            border-radius: 24px;
            pointer-events: none; /* Á¢∫‰øùÊªëÂ°ä‰∏çÊúÉÂπ≤ÊìæÈªûÊìä‰∫ã‰ª∂ */
        }

        /* ÊªëÂ°äÁöÑÂúìÂΩ¢ÊåâÈàï */
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: #d0d0d0;
            transition: .3s;
            border-radius: 50%;
        }

        /* ÈÅ∏‰∏≠ÁãÄÊÖãÁöÑÊ®£Âºè */
        input:checked + .slider {
            background-color: #4CAF50;
        }

        /* ÊªëÂ°äÊá∏ÂÅúÊïàÊûú */
        .slider:hover {
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        /* ÈÅ∏‰∏≠ÁãÄÊÖã‰∏ãÂúìÂΩ¢ÊåâÈàïÁöÑ‰ΩçÁΩÆ */
        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #ffffff;
        }

        /* Á≤íÂ≠êË¶èÂâáÂÆπÂô®ÔºàÊñ∞Â¢ûÊ®£ÂºèÔºâ */
        .rules-container {
            background: rgba(0, 0, 0, 0.2); 
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        .rules-container > div:not(.no-background) {
            background: rgba(0, 0, 0, 0.1); 
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        .matrix-container {
            overflow-x: auto;
            display: flex;
        }

        .matrix-container input[type="number"] {
            width: 100%;
            padding: 2px;
            border: none;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }


        .particle-type {
            background: rgba(0, 0, 0, 0.1);
            padding: 0 5px 5px 5px;
            border-radius: 5px;
        }
        .description {
            color: #222222;
            font-size: 12px;
            margin: 0;
        }

        .matrix-table {
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .color-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-inputs input[type="color"],
        .color-inputs input[type="range"] {
            flex: 1;
        }
    </style>
</head>

<body>
    <button id="toggle-controls">‚ò∞</button>
    <div id="controls">
        <div class="rules-container">
            <h3>üìã Á≤íÂ≠êÁ≥ªÁµ±Ë®≠ÁΩÆ</h3>
            <div class="control-section">
                <h3>Âü∫Êú¨Ë®≠ÁΩÆ</h3>
                <div>
                    <label for="particle-types">Á≤íÂ≠êÈ°ûÂûãÊï∏Èáè:</label>
                    <input type="number" id="particle-types" min="1" max="10" value="3">
                </div>
            </div>
            
            <div id="particle-settings" class="no-background">
                <!-- ÂãïÊÖãÁîüÊàêÁöÑÁ≤íÂ≠êË®≠ÁΩÆ -->
            </div>
            
            <div id="interaction-matrix" class="no-background">
                <!-- ÂãïÊÖãÁîüÊàêÁöÑ‰∫§‰∫íÁü©Èô£ -->
            </div>
        </div>
        
        <div class="toggle-container">
            <label for="isThrough" class="toggle-label">üîÅ ÁÑ°ÈÇäÁïåÊ®°Âºè</label>
            <div class="toggle-switch">
                <input type="checkbox" id="isThrough">
                <span class="slider"></span>
            </div>
        </div>

        <!-- Â∞áÊåâÈàïÁµÑÈáçÁµÑÁπî‰∏¶Ê∑ªÂä†Ê®£Âºè -->
        <div class="button-group">
            <!-- Âü∫Êú¨Êìç‰ΩúÊåâÈàï -->
            <div class="control-section">
                <h3>üéÆ Âü∫Êú¨Êìç‰Ωú</h3>
                <div class="button-container">
                    <button id="randomize-button" class="styled-button">üé≤ Èö®Ê©üÂåñÊâÄÊúâÂÄº</button>
                    <button id="restart-button" class="styled-button">üîÑ ÈáçÊñ∞ÈñãÂßãÈÅäÊà≤</button>
                    <button id="randomize-and-restart-button" class="styled-button">üéØ Èö®Ê©üÂåñ‰∏¶ÈáçÊñ∞ÈñãÂßã</button>
                </div>
            </div>

            <!-- Ë¶èÂâáÂ∞éÂÖ•Â∞éÂá∫ÊåâÈàï -->
            <div class="control-section">
                <h3>üíæ Ë¶èÂâáÁÆ°ÁêÜ</h3>
                <div class="button-container">
                    <button id="export-rules" class="styled-button">üì§ ÂåØÂá∫Ë¶èÂâá</button>
                    <button id="import-rules" class="styled-button">üì• Â∞éÂÖ•Ë¶èÂâá</button>
                    <button id="import-rules-and-restart" class="styled-button">üìã Â∞éÂÖ•Ë¶èÂâá‰∏¶ÈáçÊñ∞ÈñãÂßã</button>
                </div>
            </div>
            <input type="file" id="import-file" style="display: none;">
        </div>

        <!-- Ê∑ªÂä†ÊªëÈº†Âê∏ÂºïÂäõÊªëÂ°ä -->
        <div>
            <label for="mouse-force">ÊªëÈº†Âê∏ÂºïÂäõ:</label>
            <input type="range" id="mouse-force" min="0" max="200" step="0.1" value="100">
            <input type="number" id="mouse-force-number" min="0" max="200" step="0.1" value="100">
        </div>
        <div class="control-section">
            <h3>Áâ©ÁêÜÂèÉÊï∏</h3>
            <div class="control-item">
                <label for="t-half">Êë©Êì¶ÂçäË°∞Êúü(Áßí):</label>
                <input type="range" id="t-half" min="0.001" max="0.1" step="0.001" value="0.020">
                <input type="number" id="t-half-number" min="0.001" max="0.1" step="0.001" value="0.020">
            </div>
        </div>

        <div>
            <label for="updateInterval">Êõ¥Êñ∞ÈñìÈöî(ms):</label>
            <input type="range" id="updateInterval" min="1" max="50" step="0.01" value="16.66">
            <input type="number" id="updateInterval-number" min="1" max="50" step="0.01" value="16.66">
            <select id="updateInterval-unit">
                <option value="33.33">30 UPS</option>
                <option value="16.66" selected>60 UPS</option>
                <option value="8.33">120 UPS</option>
                <option value="6.94">144 UPS</option>
                <option value="6.06">165 UPS</option>
                <option value="4.16">240 UPS</option>
                <option value="2.77">360 UPS</option>
                <option value="2.08">480 UPS</option>
                <option value="2.00">500 UPS</option>
                <option value="1.85">540 UPS</option>
                <option value="1.66">600 UPS</option>
                <option value="1.38">720 UPS</option>
            </select>
            <p>UPS: Update Per SecondÔºåÊØèÁßíÊõ¥Êñ∞Ê¨°Êï∏</p>
            <p>Ê≥®ÊÑè: Êõ¥Êñ∞ÈñìÈöîË∂äÁü≠ÔºåÁ≤íÂ≠êÈÅãÂãïË∂äÊµÅÊö¢„ÄÇ</p>
            <p class="description">‰ΩÜÂ¶ÇÊûú‰Ω†ÁöÑÈõªËÖ¶‰∏¶‰∏çËÉΩÈÅãË°åÂà∞ÈÇ£È∫ºÁü≠ÁöÑÊõ¥Êñ∞ÈñìÈöîÔºå\nÈÇ£È∫º‰Ω†ÁöÑÈõªËÖ¶Â∞±ÁÑ°Ê≥ïÈÅãË°åÂà∞ÈÇ£È∫ºÁü≠ÁöÑÊõ¥Êñ∞ÈñìÈöî„ÄÇ</p>
        </div>

        <!-- Âú®ÊéßÂà∂Èù¢Êùø‰∏≠Ê∑ªÂä†ÊÄßËÉΩÊï∏ÊìöÈ°ØÁ§∫ -->
        <div id="performance-data">
            <h3>ÊÄßËÉΩÊï∏Êìö</h3>
            <p>Ê∏≤ÊüìFPS: <span id="fps"></span><br>(ÈÄô‰∏¶‰∏çÊòØÈÅäÊà≤ÊØèÁßíÊõ¥Êñ∞Ê¨°Êï∏„ÄÇ)</p>
            <p>ÈÅäÊà≤UPS: <span id="gameUPS"></span><br>(ÈÄôÊòØÈÅäÊà≤ÊØèÁßíÊõ¥Êñ∞Ê¨°Êï∏„ÄÇ)</p>
            <p>Á≤íÂ≠êÊõ¥Êñ∞Á∏ΩÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="total-time"></span> ms 
                <br>Âπ≥Âùá: <span id="total-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="total-time-max"></span> ms
            </p>
            <p>Á∂≤Ê†ºÈáçÁΩÆÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="grid-reset-time"></span> ms 
                <br>Âπ≥Âùá: <span id="grid-reset-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="grid-reset-time-max"></span> ms
                <br>ÂñÆÊ¨°Âπ≥Âùá: <span id="grid-reset-time-single-average"></span> ms
                <br>ÊØèÊõ¥Êñ∞Âü∑Ë°åÊ¨°Êï∏: <span id="grid-reset-time-run-per-update"></span> Ê¨°
            </p>
            <p>ÂèñÂæóÈôÑËøëÁ≤íÂ≠êÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="get-nearby-time"></span> ms 
                <br>Âπ≥Âùá: <span id="get-nearby-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="get-nearby-time-max"></span> ms
                <br>ÂñÆÊ¨°Âπ≥Âùá: <span id="get-nearby-time-single-average"></span> ms
                <br>ÊØèÊõ¥Êñ∞Âü∑Ë°åÊ¨°Êï∏: <span id="get-nearby-time-run-per-update"></span> Ê¨°
            </p>
            <p>ÈáçÂäõÂΩ±ÈüøË®àÁÆóÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="g-Affect-Calc-time"></span> ms 
                <br>Âπ≥Âùá: <span id="g-Affect-Calc-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="g-Affect-Calc-time-max"></span> ms
                <br>ÂñÆÂÄãÁ≤íÂ≠êÂπ≥Âùá: <span id="g-Affect-Calc-time-single-average"></span> ms
                <br>ÊØèÊõ¥Êñ∞Âü∑Ë°åÊ¨°Êï∏: <span id="g-Affect-Calc-time-run-per-update"></span> Ê¨°
                </p>
            <p>Êõ¥Êñ∞‰ΩçÁΩÆÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="position-update-time"></span> ms 
                <br>Âπ≥Âùá: <span id="position-update-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="position-update-time-max"></span> ms
                <br>ÂñÆÊ¨°Âπ≥Âùá: <span id="position-update-time-single-average"></span> ms
                <br>ÊØèÊõ¥Êñ∞Âü∑Ë°åÊ¨°Êï∏: <span id="position-update-time-run-per-update"></span> Ê¨°
            </p>
            <p>Á≤íÂ≠êÂΩ±ÈüøÁØÑÂúçË®àÁÆóÊôÇÈñì: 
                <br>Áï∂Ââç: <span id="Particle-Affect-Calc-time"></span> ms 
                <br>Âπ≥Âùá: <span id="Particle-Affect-Calc-time-average"></span> ms
                <br>ÊúÄÂ§ß: <span id="Particle-Affect-Calc-time-max"></span> ms
            </p>
        </div>

        <!-- Âú®ÊéßÂà∂Èù¢Êùø‰∏≠Ê∑ªÂä†Êñ∞ÁöÑÊéßÂà∂ÂÖÉÁ¥† -->
        <div class="grid-controls">
            <h3>‚åó Á∂≤Ê†ºË®≠ÁΩÆ</h3>
            <div class="toggle-container">
                <label for="showGrid" class="toggle-label">üî≤ È°ØÁ§∫Á∂≤Ê†º</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="showGrid">
                    <span class="slider"></span>
                </div>
            </div>
            <div>
                <p>Áï∂ÂâçÊâÄÈÅ∏ÂñÆÂÖÉÊ†º: <span id="selected-cell"></span></p>
                <p>Á∂≤Ê†ºÂØ¨Â∫¶: <span id="grid-width"></span></p>
                <p>Á∂≤Ê†ºÈ´òÂ∫¶: <span id="grid-height"></span></p>
            </div>
            <div>
                <label for="setectGridDistance">Ê®°Êì¨‰ΩúÁî®ÁØÑÂúç: </label>
                <input type="range" id="setectGridDistance" min="10" max="500" step="10" value="250">
                <input type="number" id="setectGridDistance-number" min="10" max="500" step="10" value="250">
            </div>
            <div>
                <label for="cell-size">Á∂≤Ê†ºÂ§ßÂ∞è:</label>
                <input type="range" id="cell-size" min="10" max="100" step="1" value="50">
                <input type="number" id="cell-size-number" min="10" max="100" step="1" value="50">
            </div>
        </div>

        <!-- Âú®ÊÄßËÉΩÊï∏ÊìöÈ°ØÁ§∫ÂçÄÂüü‰πãÂæåÊ∑ªÂä†‰ª•‰∏ã‰ª£Á¢º -->
        <div>
            <h3>‚ò¢Ô∏è Á≤íÂ≠êÂΩ±ÈüøÁØÑÂúçÈ°ØÁ§∫</h3>
            <div class="toggle-container">
                <label for="enableParticleAffcetRadiusShow" class="toggle-label">ÂïüÁî®Á≤íÂ≠êÂΩ±ÈüøÁØÑÂúçÈ°ØÁ§∫: </label>
                <div class="toggle-switch">
                    <input type="checkbox" id="enableParticleAffcetRadiusShow">
                    <span class="slider"></span>
                </div>
            </div>
            <div id="particle-affcet-radius-show" class="no-background">
                <!-- ÂãïÊÖãÁîüÊàêÁöÑÁ≤íÂ≠êÂΩ±ÈüøÁØÑÂúçÈ°ØÁ§∫Ë®≠ÁΩÆ -->
            </div>
            <div>
                <p>ÈÅ∏‰∏≠ÁöÑÁ≤íÂ≠êID: <span id="selectedParticleId">ÁÑ°</span></p>
                <p>ÈÅ∏‰∏≠ÁöÑÁ≤íÂ≠êÂ±¨ÊÄß: <span id="selectedParticleProperty"></span></p>
                <div id="particle-nearby-particles" class="no-background">
                    <!-- ÂãïÊÖãÁîüÊàêÁöÑÁ≤íÂ≠êÁØÑÂúçÂÖßÁöÑ{i}ËôüÁ≤íÂ≠êÊï∏Èáè -->
                </div>
            </div>
        </div>
        <div>
            <p style="font-size: 1.2em; font-weight: bold; color: #ff6b6b; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); margin: 15px 0;">üí¨ ‰∫§ÊµÅËàáÂèçÈ•ã</p>
            <a href="https://github.com/onenok/ParticlesLife.html/issues" style="text-decoration: none; display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 6px; background: #24292e; color: white; width: fit-content; transition: background 0.2s;">
                <svg height="24" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="24" fill="currentColor">
                    <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
                </svg>
                <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">GitHub Issues</span>
            </a>
        </div>
    </div>
    <canvas id="board2d"></canvas>

    <script>
        // ÂâµÂª∫ Web Worker
        const worker = new Worker('particleWorker.js');
        // Áî®Êà∂ÂèØÊéßÂà∂Êï∏ÊìöÁöÑÂàùÂßãÂåñ
        const gameState = {
            // Á≤íÂ≠êÁ≥ªÁµ±Âü∫Êú¨Ë®≠ÁΩÆ
            particleTypes: 3,
            particleCounts: [250, 250, 250],
            particleColors: [
                'hsl(0, 100%, 50%)',   // Á¥ÖËâ≤
                'hsl(120, 100%, 50%)', // Á∂†Ëâ≤
                'hsl(240, 100%, 50%)'  // ËóçËâ≤
            ],
            particleGroups: [],
            // ‰∫§‰∫íÁü©Èô£
            forceMatrix: [
                [1, 0.5, 0],
                [0, 1, 0.5],
                [0.5, 0, 1]
            ],
            distanceMatrix: [
                [300, 300, 300],
                [300, 300, 300],
                [300, 300, 300]
            ],
            
            // Áâ©ÁêÜÂèÉÊï∏
            tHalf: 0.020,         // Êë©Êì¶ÂçäË°∞Êúü
            dt: 1/144,           // ÊôÇÈñìÊ≠•Èï∑
            
            // È°ØÁ§∫Ë®≠ÁΩÆ
            isThrough: false,     // ÁÑ°ÈÇäÁïåÊ®°Âºè
            showGrid: false,      // È°ØÁ§∫Á∂≤Ê†º
            gridData: {
                cellSize: 50,
                width: 0,
                height: 0,
                selectedCell: null,
                nearbyCells: []
            },
            
            // ÊªëÈº†‰∫§‰∫í
            mouseForce: 100,
            
            // ÂÖ∂‰ªñË®≠ÁΩÆ
            setectGridDistance: 250,
            enableParticleAffcetRadiusShow: false,
            selectedParticleId: null,
            selectedParticleType: null,
            nearbyParticlesList: [],
            ballRadius: 1.5,
            RadiusShow: [true, true, true],
            // Êõ¥Êñ∞ÊéßÂà∂
            updateInterval: 16.66    // Á¥Ñ 60 FPS
        };
        document.addEventListener('DOMContentLoaded', () => {
            const canvas2d = document.getElementById("board2d");
            const ctx = canvas2d.getContext("2d");

            // ÁßªÈô§ WebGL Áõ∏ÈóúËÆäÈáè
            /*
            let useWebGL = false; // ‰øùÁïôÈÄôÂÄãËÆäÈáèÔºå‰ΩÜÂßãÁµÇÁÇ∫ false
            */

            function updateCanvasSize() {
                const controlPanel = document.getElementById('controls');
                const isPanelVisible = controlPanel.classList.contains('visible');
                const width = document.documentElement.clientWidth - (isPanelVisible ? 300 : 0);
                const height = document.documentElement.clientHeight;

                canvas2d.width = width;
                canvas2d.height = height;

                // Ë®≠ÁΩÆ Canvas Ê®£Âºè
                canvas2d.style.position = 'absolute';
                canvas2d.style.left = '0';
                canvas2d.style.top = '0';

                worker.postMessage({ type: 'updateCanvasSize', width, height });
            }

            function draw(particles, gridData) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);
                if (gameState.showGrid && gridData) {
                    drawGrid(ctx, gridData);
                }

                
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, gameState.ballRadius, 0, Math.PI * 2);
                    
                    if (gameState.enableParticleAffcetRadiusShow) {
                        if (gameState.selectedParticleId === null) {
                            ctx.fillStyle = 'gray';
                            ctx.fill();
                            ctx.closePath();
                        }else if (p.id === gameState.selectedParticleId) {
                            let isXOverflow = false;
                            let isYOverflow = false;
                            let newx = p.x;
                            let newy = p.y;
                            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                            ctx.fill();
                            ctx.closePath();
                            for (let i = 0; i < gameState.RadiusShow.length; i++) {
                                if (gameState.RadiusShow[i]) {
                                    hsl = gameState.particleColors[i];
                                    h = hsl.match(/hsl\((\d+),\s*\d+%,\s*\d+%\)/)[1];
                                    hsla = `hsla(${h}, 100%, 50%, 0.3)`;
                                    radius = gameState.distanceMatrix[gameState.selectedParticleType][i];
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                                    ctx.fillStyle = hsla;
                                    ctx.fill();
                                    ctx.closePath();
                                    if (throughCheckbox.checked) {
                                        isXOverflow = false;
                                        isYOverflow = false;
                                        newx = p.x;
                                        newy = p.y;
                                        if ((p.x < radius || p.x > canvas2d.width - radius)){
                                            isXOverflow = true;
                                            newx = p.x < radius ? p.x + canvas2d.width : p.x - canvas2d.width;
                                            ctx.beginPath();
                                            ctx.arc(newx, p.y, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if ((p.y < radius || p.y > canvas2d.height - radius)){
                                            isYOverflow = true;
                                            newy = p.y < radius ? p.y + canvas2d.height : p.y - canvas2d.height;
                                            ctx.beginPath();
                                            ctx.arc(p.x, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if (isXOverflow && isYOverflow) {
                                            ctx.beginPath();
                                            ctx.arc(newx, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                    }
                                }
                            }
                        } else { 
                            if (gameState.RadiusShow[p.type]) {
                                ctx.fillStyle = (gameState.nearbyParticlesList[p.type]||[]).includes(p) ? p.color : 'gray';
                                ctx.fill();
                                ctx.closePath();
                            }
                        }
                    } else {
                        ctx.fillStyle = p.isOutside ? 'white' : p.color;
                        ctx.fill();
                        ctx.closePath();
                    }
                });
            }

            function drawGrid(ctx, gridData) {
                //console.log(gridData);
                const { cellSize, width, height, selectedCell, nearbyCells } = gridData;
                const canvasWidth = canvas2d.width;
                const canvasHeight = canvas2d.height;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                // Áπ™Ë£ΩÂûÇÁõ¥Á∑ö
                for (let x = 0; x <= width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, Math.min(height * cellSize, canvasHeight));
                    ctx.stroke();
                }

                // Áπ™Ë£ΩÊ∞¥Âπ≥Á∑ö
                for (let y = 0; y <= height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(Math.min(width * cellSize, canvasWidth), y * cellSize);
                    ctx.stroke();
                }

                // Áπ™Ë£ΩÈÅ∏‰∏≠ÁöÑÂñÆÂÖÉÊ†ºÂíåÈôÑËøëÁöÑÂñÆÂÖÉÊ†º
                if (selectedCell) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.fillRect(selectedCell.x * cellSize, selectedCell.y * cellSize, cellSize, cellSize);

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    nearbyCells.forEach(cell => {
                        ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                    });
                }
            }

            // ÂàùÂßãÂåñÈÅäÊà≤ÂáΩÊï∏‰øÆÊîπ
            function initGame() {
                let performanceData = {
                    totalTime: 0,
                    totalTimeAll: [],
                    totalTimeMax: 0,
                    gridResetTime: 0,
                    gridResetTimeAll: [],
                    gridResetTimeMax: 0,
                    getNearbyTime: 0,
                    getNearbyTimeAll: [],
                    getNearbyTimeMax: 0,
                    gAffectCalcTime: 0,
                    gAffectCalcTimeAll: [],
                    gAffectCalcTimeMax: 0,
                    positionUpdateTime: 0,
                    positionUpdateTimeAll: [],
                    positionUpdateTimeMax: 0,
                    ParticleAffcetCalcTime: 0,
                    ParticleAffcetCalcTimeAll: [],
                    ParticleAffcetCalcTimeMax: 0
                };
                worker.postMessage({
                    type: 'init',
                    particleCounts: gameState.particleCounts,
                    canvasWidth: canvas2d.width,
                    canvasHeight: canvas2d.height,
                    particleColors: gameState.particleColors,
                    particleTypes: gameState.particleTypes,
                    performanceData: performanceData,
                    cellSize: gameState.gridData.cellSize
                });
            }

            // ÂàùÂßãÂåñ canvas Â∞∫ÂØ∏
            updateCanvasSize();

            // Áõ£ËÅΩË¶ñÁ™óÂ§ßÂ∞èËÆäÂåñ
            window.addEventListener("resize", updateCanvasSize);

            // Ê∑ªÂä† FPS Ë®àÁÆóÁõ∏ÈóúËÆäÈáè
            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 0;
            let gameFPS = 0;

            let particles = [];
            let performanceData = {
                totalTime: 0,
                totalTimeAll: [],
                totalTimeMax: 0,
                totalTimeAverage: 0,
                gridResetTime: 0,
                gridResetTimeAll: [],
                gridResetTimeMax: 0,
                gridResetTimeAverage: 0,
                getNearbyTime: 0,
                getNearbyTimeAll: [],
                getNearbyTimeMax: 0,
                getNearbyTimeAverage: 0,
                gAffectCalcTime: 0,
                gAffectCalcTimeAll: [],
                gAffectCalcTimeMax: 0,
                gAffectCalcTimeAverage: 0,
                positionUpdateTime: 0,
                positionUpdateTimeAll: [],
                positionUpdateTimeMax: 0,
                positionUpdateTimeAverage: 0,
                ParticleAffcetCalcTime: 0,
                ParticleAffcetCalcTimeAll: [],
                ParticleAffcetCalcTimeMax: 0,
                ParticleAffcetCalcTimeAverage: 0
            };
            let totalTimeAverageUpdateMs = 1000;
            let gridResetTimeAverageUpdateMs = 1000;
            let getNearbyTimeAverageUpdateMs = 1000;
            let gAffectCalcTimeAverageUpdateMs = 1000;
            let positionUpdateTimeAverageUpdateMs = 1000;
            let ParticleAffcetCalcTimeAverageUpdateMs = 1000;
            let totalTimeAverageUpdateLastTime = 0;
            let gridResetTimeAverageUpdateLastTime = 0;
            let getNearbyTimeAverageUpdateLastTime = 0;
            let gAffectCalcTimeAverageUpdateLastTime = 0;
            let positionUpdateTimeAverageUpdateLastTime = 0;
            let ParticleAffcetCalcTimeAverageUpdateLastTime = 0;
            function update() {
                // Êõ¥Êñ∞ÊâÄÈÅ∏ÂñÆÂÖÉÊ†ºÁöÑÈ°ØÁ§∫
                if (gameState.gridData.selectedCell) {
                    document.getElementById('selected-cell').textContent = `x: ${gameState.gridData.selectedCell.x}, y: ${gameState.gridData.selectedCell.y}`;
                } else {
                    document.getElementById('selected-cell').textContent = 'ÁÑ°';
                }
                draw(particles, gameState.gridData);
                if (performanceData.totalTime > performanceData.totalTimeMax) {
                    performanceData.totalTimeMax = performanceData.totalTime;
                }
                if (performanceData.gridResetTime > performanceData.gridResetTimeMax){
                    performanceData.gridResetTimeMax = performanceData.gridResetTime;
                }
                if (performanceData.getNearbyTime > performanceData.getNearbyTimeMax){
                    performanceData.getNearbyTimeMax = performanceData.getNearbyTime;
                }
                if (performanceData.gAffectCalcTime > performanceData.gAffectCalcTimeMax){
                    performanceData.gAffectCalcTimeMax = performanceData.gAffectCalcTime;
                }
                if (performanceData.positionUpdateTime > performanceData.positionUpdateTimeMax){
                    performanceData.positionUpdateTimeMax = performanceData.positionUpdateTime;
                }
                if (performanceData.ParticleAffcetCalcTime > performanceData.ParticleAffcetCalcTimeMax){
                    performanceData.ParticleAffcetCalcTimeMax = performanceData.ParticleAffcetCalcTime;
                }
                performanceData.totalTimeAll.push(performanceData.totalTime);
                performanceData.gridResetTimeAll.push(performanceData.gridResetTime);
                performanceData.getNearbyTimeAll.push(performanceData.getNearbyTime);
                performanceData.gAffectCalcTimeAll.push(performanceData.gAffectCalcTime);
                performanceData.positionUpdateTimeAll.push(performanceData.positionUpdateTime);
                performanceData.ParticleAffcetCalcTimeAll.push(performanceData.ParticleAffcetCalcTime);
                // Êõ¥Êñ∞ÊÄßËÉΩÊï∏ÊìöÈ°ØÁ§∫
                document.getElementById('total-time').textContent = performanceData.totalTime.toFixed(2);
                if (performance.now() - totalTimeAverageUpdateLastTime >= totalTimeAverageUpdateMs) {
                    performanceData.totalTimeAverage = performanceData.totalTimeAll.reduce((a, b) => a + b, 0) / performanceData.totalTimeAll.length;
                    document.getElementById('total-time-average').textContent = performanceData.totalTimeAverage.toFixed(2);
                    performanceData.totalTimeAll = [];  
                    totalTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('total-time-max').textContent = performanceData.totalTimeMax.toFixed(2);
                
                document.getElementById('grid-reset-time').textContent = performanceData.gridResetTime.toFixed(2);  
                if (performance.now() - gridResetTimeAverageUpdateLastTime >= gridResetTimeAverageUpdateMs) {
                    performanceData.gridResetTimeAverage = performanceData.gridResetTimeAll.reduce((a, b) => a + b, 0) / performanceData.gridResetTimeAll.length;
                    document.getElementById('grid-reset-time-average').textContent = performanceData.gridResetTimeAverage.toFixed(2);
                    performanceData.gridResetTimeAll = [];
                    gridResetTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('grid-reset-time-max').textContent = performanceData.gridResetTimeMax.toFixed(2);
                document.getElementById('grid-reset-time-single-average').textContent = (performanceData.gridResetTimeAverage/gameState.particleTypes).toFixed(2);
                document.getElementById('grid-reset-time-run-per-update').textContent = gameState.particleTypes;

                document.getElementById('get-nearby-time').textContent = performanceData.getNearbyTime.toFixed(2);
                if (performance.now() - getNearbyTimeAverageUpdateLastTime >= getNearbyTimeAverageUpdateMs) {
                    performanceData.getNearbyTimeAverage = performanceData.getNearbyTimeAll.reduce((a, b) => a + b, 0) / performanceData.getNearbyTimeAll.length;
                    document.getElementById('get-nearby-time-average').textContent = performanceData.getNearbyTimeAverage.toFixed(2);
                    performanceData.getNearbyTimeAll = [];
                    getNearbyTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('get-nearby-time-max').textContent = performanceData.getNearbyTimeMax.toFixed(2);
                document.getElementById('get-nearby-time-single-average').textContent = (performanceData.getNearbyTimeAverage/(gameState.particleTypes*particles.length)).toFixed(2);
                document.getElementById('get-nearby-time-run-per-update').textContent = gameState.particleTypes*particles.length;

                document.getElementById('g-Affect-Calc-time').textContent = performanceData.gAffectCalcTime.toFixed(2);
                if (performance.now() - gAffectCalcTimeAverageUpdateLastTime >= gAffectCalcTimeAverageUpdateMs) {
                    performanceData.gAffectCalcTimeAverage = performanceData.gAffectCalcTimeAll.reduce((a, b) => a + b, 0) / performanceData.gAffectCalcTimeAll.length;
                    document.getElementById('g-Affect-Calc-time-average').textContent = performanceData.gAffectCalcTimeAverage.toFixed(2);
                    performanceData.gAffectCalcTimeAll = [];
                    gAffectCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('g-Affect-Calc-time-max').textContent = performanceData.gAffectCalcTimeMax.toFixed(2);
                document.getElementById('g-Affect-Calc-time-single-average').textContent = (performanceData.gAffectCalcTimeAverage/(gameState.particleTypes*particles.length)).toFixed(2);
                document.getElementById('g-Affect-Calc-time-run-per-update').textContent = gameState.particleTypes*particles.length;
                
                document.getElementById('position-update-time').textContent = performanceData.positionUpdateTime.toFixed(2);
                if (performance.now() - positionUpdateTimeAverageUpdateLastTime >= positionUpdateTimeAverageUpdateMs) {
                    performanceData.positionUpdateTimeAverage = performanceData.positionUpdateTimeAll.reduce((a, b) => a + b, 0) / performanceData.positionUpdateTimeAll.length;
                    document.getElementById('position-update-time-average').textContent = performanceData.positionUpdateTimeAverage.toFixed(2);
                    performanceData.positionUpdateTimeAll = [];
                    positionUpdateTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('position-update-time-max').textContent = performanceData.positionUpdateTimeMax.toFixed(2);
                document.getElementById('position-update-time-single-average').textContent = (performanceData.positionUpdateTimeAverage/particles.length).toFixed(2);
                document.getElementById('position-update-time-run-per-update').textContent = particles.length

                document.getElementById('Particle-Affect-Calc-time').textContent = performanceData.ParticleAffcetCalcTime.toFixed(2);
                if (performance.now() - ParticleAffcetCalcTimeAverageUpdateLastTime >= ParticleAffcetCalcTimeAverageUpdateMs) {
                    performanceData.ParticleAffcetCalcTimeAverage = performanceData.ParticleAffcetCalcTimeAll.reduce((a, b) => a + b, 0) / performanceData.ParticleAffcetCalcTimeAll.length;
                    document.getElementById('Particle-Affect-Calc-time-average').textContent = performanceData.ParticleAffcetCalcTimeAverage.toFixed(2);
                    performanceData.ParticleAffcetCalcTimeAll = [];
                    ParticleAffcetCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('Particle-Affect-Calc-time-max').textContent = performanceData.ParticleAffcetCalcTimeMax.toFixed(2);

                // Êõ¥Êñ∞ÈÅ∏‰∏≠Á≤íÂ≠êÁöÑÂ±¨ÊÄßÈ°ØÁ§∫
                if (gameState.enableParticleAffcetRadiusShow){
                    const propertyElement = document.getElementById('selectedParticleProperty');
                    if (gameState.selectedParticleId !== null && particles.length > 0) {
                        const selectedParticle = particles.find(p => p.id === gameState.selectedParticleId);
                        if (selectedParticle) {
                            const properties = [
                                `\n`,
                                `È°ûÂûã: ${selectedParticle.type + 1}`,
                                `‰ΩçÁΩÆ: (${selectedParticle.x.toFixed(2)}, ${selectedParticle.y.toFixed(2)})`,
                                `ÈÄüÂ∫¶: (${selectedParticle.vx.toFixed(2)}, ${selectedParticle.vy.toFixed(2)})`,
                                `È°èËâ≤: ${selectedParticle.color}`,
                                `ÊòØÂê¶Âú®ÈÇäÁïåÂ§ñ: ${selectedParticle.isOutside ? 'ÊòØ' : 'Âê¶'}`
                            ];
                            propertyElement.innerHTML = properties.join('<br>');
                        } else {
                            propertyElement.textContent = 'Êâæ‰∏çÂà∞ÈÅ∏‰∏≠ÁöÑÁ≤íÂ≠ê';
                        }
                    } else {
                        propertyElement.textContent = 'Êú™ÈÅ∏‰∏≠Á≤íÂ≠ê';
                    }
                }

                // Ë®àÁÆó‰∏¶È°ØÁ§∫ FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    document.getElementById('fps').textContent = fps;
                    frameCount = 0;
                    lastTime = currentTime;
                }
                gameUPS = (1000 / (performanceData.totalTimeAverage)).toFixed(0);
                document.getElementById('gameUPS').textContent = gameUPS;
                requestAnimationFrame(() => {
                    worker.postMessage({ type: 'canUpdate' });
                    update();
                });
            }

            // Êé•Êî∂‰æÜËá™ Worker ÁöÑÊ∂àÊÅØ
            worker.onmessage = function (e) {
                if (e.data.type === 'update') {
                    particles = e.data.particles;
                    particleGroups = e.data.particleGroups;
                    gameState.gridData.nearbyCells = e.data.nearbyCells;
                    gameState.gridData.width = e.data.gridDataWidth;
                    gameState.gridData.height = e.data.gridDataHeight;
                    performanceData.totalTime = e.data.performanceData.totalTime;
                    performanceData.gridResetTime = e.data.performanceData.gridResetTime
                    performanceData.getNearbyTime = e.data.performanceData.getNearbyTime
                    performanceData.gAffectCalcTime = e.data.performanceData.gAffectCalcTime;
                    performanceData.positionUpdateTime = e.data.performanceData.positionUpdateTime;
                    performanceData.ParticleAffcetCalcTime = e.data.performanceData.ParticleAffcetCalcTime;
                    if (gameState.enableParticleAffcetRadiusShow){
                        gameState.nearbyParticlesList = e.data.nearbyParticlesList;
                        for (let i = 0; i < gameState.nearbyParticlesList.length; i++) {
                            //console.log(`gameState.nearbyParticlesList[${i}]: ${gameState.nearbyParticlesList[i]}`);
                            document.getElementById(`particle-nearby-particles-${i}`).textContent = `ÁØÑÂúçÂÖßÁöÑÈ°ûÂûã${i + 1}Á≤íÂ≠êÊï∏Èáè: ${gameState.nearbyParticlesList[i] ? gameState.nearbyParticlesList[i].length : 0}`;
                        }
                    }

                    // Êõ¥Êñ∞Á∂≤Ê†ºÂØ¨Â∫¶ÂíåÈ´òÂ∫¶ÁöÑÈ°ØÁ§∫
                    document.getElementById('grid-width').textContent = gameState.gridData.width;
                    document.getElementById('grid-height').textContent = gameState.gridData.height;
                }
            };

            // Êõ¥Êñ∞Ë¶èÂâá
            function updateRules() {
                // ‰ΩøÁî® gameState ‰∏≠ÁöÑÁü©Èô£Êï∏Êìö
                worker.postMessage({
                    type: 'updateRules',
                    forceMatrix: gameState.forceMatrix,
                    distanceMatrix: gameState.distanceMatrix
                });
            }

            
            

            // Èö®Ê©üÂåñÂÄº
            function randomizeValues() {
                document.querySelectorAll('.particle-force').forEach(p => {
                    const value = (Math.random() * 2 - 1).toFixed(1);
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                document.querySelectorAll('.particle-distance').forEach(p => {
                    const value = Math.floor(Math.random() * (300 - 10 + 1)) + 10;
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                updateRules();
            }

            // Èö®Ê©üÂåñ‰∏¶ÈáçÊñ∞ÈñãÂßã
            function randomizeAndRestart() {
                randomizeValues();
                initGame();
            }

            // ÊéßÂà∂ÊùøÂàáÊèõ
            const toggleButton = document.getElementById('toggle-controls');
            const controlPanel = document.getElementById('controls');

            toggleButton.addEventListener('click', () => {
                controlPanel.classList.toggle('visible');
                if (controlPanel.classList.contains('visible')) {
                    toggleButton.style.right = '310px';
                    toggleButton.textContent = '‚úï';
                } else {
                    toggleButton.style.right = '10px';
                    toggleButton.textContent = '‚ò∞';
                }
                updateCanvasSize();
            });

            // Ëá™ÂãïÈö±ËóèÂàáÊèõÊåâÈàï
            let hideTimeout;
            document.addEventListener('mousemove', () => {
                toggleButton.style.opacity = '0.5';
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    toggleButton.style.opacity = '0';
                }, 3000);
            });

            // ÂåØÂá∫Ë¶èÂâá
            function exportRules() {
                const rules = {};
                // Ê∑ªÂä†Ë¶èÂâá
                rules['force'] = gameState.forceMatrix;
                rules['distance'] = gameState.distanceMatrix;
                // Ê∑ªÂä†Á≤íÂ≠êÊï∏Èáè
                rules['particleCounts'] = gameState.particleCounts;
                // Ê∑ªÂä†Á≤íÂ≠êÈ°ûÂûã
                rules['particleTypes'] = gameState.particleTypes;
                // Ê∑ªÂä†Á≤íÂ≠êÈ°èËâ≤
                rules['particleColors'] = gameState.particleColors;
                // Ê∑ªÂä†Á©øÈÄèÊ®°ÂºèÁãÄÊÖã
                rules['isThrough'] = document.getElementById('isThrough').checked;
                rules['tHalf'] = gameState.tHalf;
                rules['dt'] = gameState.dt;
                rules['mouseForce'] = gameState.mouseForce;
                rules['gridData'] = gameState.gridData;

                // Ê∑ªÂä†È°èËâ≤
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(rules));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "particle_rules.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            // Â∞éÂÖ•Ë¶èÂâá
            function importRules(shouldRestart) {
                const fileInput = document.getElementById('import-file');
                fileInput.value = '';
                fileInput.dataset.shouldRestart = shouldRestart;
                fileInput.click();
            }

            function handleFileSelect(event) {
                const file = event.target.files[0];
                const shouldRestart = event.target.dataset.shouldRestart === 'true';
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const rules = JSON.parse(e.target.result);
                        Object.keys(rules).forEach(id => {
                            if (id === 'isThrough') {
                                // Ë®≠ÁΩÆÁ©øÈÄèÊ®°ÂºèÁãÄÊÖã
                                const throughCheckbox = document.getElementById('isThrough');
                                throughCheckbox.checked = rules[id];
                                throughCheckbox.dispatchEvent(new Event('change'));
                            } else if (id === 'particleCounts') {
                                gameState.particleCounts = rules[id];
                            } else if (id === 'particleTypes') {
                                gameState.particleTypes = rules[id];
                            } else if (id === 'particleColors') {
                                gameState.particleColors = rules[id];
                            } else if (id === 'tHalf') {
                                gameState.tHalf = rules[id];
                            } else if (id === 'dt') {
                                gameState.dt = rules[id];
                            } else if (id === 'mouseForce') {
                                gameState.mouseForce = rules[id];
                            } else if (id === 'gridData') {
                                gameState.gridData = rules[id];
                            } else if (id === 'forceMatrix') {
                                gameState.forceMatrix = rules[id];
                            } else if (id === 'distanceMatrix') {
                                gameState.distanceMatrix = rules[id];
                            }
                            updateHTML();
                        });
                        updateRules();
                        if (shouldRestart) {
                            setTimeout(initGame, 100);
                        }
                    };
                    reader.readAsText(file);
                }
            }

            // Êõ¥Êñ∞È°èËâ≤
            function updateColors() {
                //console.log(`index.html: gameState.particleColors: ${gameState.particleColors}`);
                worker.postMessage({
                    type: 'updateColors',
                    particleColors: gameState.particleColors
                });
            }

            // ÁÇ∫ÂåØÂá∫Ë¶èÂâáÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('export-rules').addEventListener('click', exportRules);
            // ÁÇ∫Â∞éÂÖ•Ë¶èÂâáÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('import-rules').addEventListener('click', () => importRules(false));
            // ÁÇ∫Â∞éÂÖ•Ë¶èÂâá‰∏¶ÈáçÊñ∞ÈñãÂßãÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('import-rules-and-restart').addEventListener('click', () => importRules(true));
            // ÁÇ∫Â∞éÂÖ•Êñá‰ª∂Ê∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('import-file').addEventListener('change', handleFileSelect);

            let mouseX = 0;
            let mouseY = 0;
            let isMouseDown = false;
            let isUpdateMouse = false;
            let isUpdateMouseDownUp = false;

            // Á©øÈÄèÊ®°ÂºèÂàáÊèõ
            const throughCheckbox = document.getElementById("isThrough");
            throughCheckbox.addEventListener('change', () => {
                worker.postMessage({ type: 'setThrough', isThrough: throughCheckbox.checked });
            });
            
            // Ê∑ªÂä†ÊåâÈàï‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('randomize-button').addEventListener('click', randomizeValues);
            document.getElementById('restart-button').addEventListener('click', initGame);
            document.getElementById('randomize-and-restart-button').addEventListener('click', randomizeAndRestart);
            document.addEventListener("keydown", function(event) {
                if (event.key === "r") {
                    randomizeValues();
                }
                if (event.key === "s") {
                    initGame();
                }
                if (event.key === "f") {
                    randomizeAndRestart();
                }
                if (event.key === "x") {
                    isUpdateMouseDownUp = false;
                }
                if (event.key === "m") {
                    isUpdateMouse = false;
                }
                if (event.key === "t") {
                    throughCheckbox.checked = !throughCheckbox.checked;
                    throughCheckbox.dispatchEvent(new Event('change'));
                }
            });

            // Ê∑ªÂä†ÊªëÈº†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            canvas2d.addEventListener('mousedown', (e) => {
                if (!gameState.enableParticleAffcetRadiusShow){
                    isUpdateMouseDownUp = true;
                    isUpdateMouse = true;
                    isMouseDown = true;
                    updateMousePosition(e);
                }
            });

            canvas2d.addEventListener('mouseup', () => {
                if (isUpdateMouseDownUp) {
                    isMouseDown = false;
                    worker.postMessage({ type: 'setMouseInactive' });
                }
            });

            canvas2d.addEventListener('mousemove', (e) => {
                if (isUpdateMouse) {
                    updateMousePosition(e);
                }
            });

            function updateMousePosition(e) {
                const rect = canvas2d.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                if (isMouseDown) {
                    worker.postMessage({ type: 'updateMousePosition', x: mouseX, y: mouseY });
                }
            }

            function updateMouseForce(){
                worker.postMessage({ type: 'updateMouseForce', force: gameState.mouseForce });
            }
            function updateCellSize(){
                worker.postMessage({ type: 'updateCellSize', size: gameState.gridData.cellSize });
            }
            function updateSetectGridDistance(){
                worker.postMessage({ type: 'updateSetectGridDistance', distance: gameState.setectGridDistance });
            }
            function updateUpdateInterval(){
                worker.postMessage({ type: 'updateUpdateInterval', interval: gameState.updateInterval });
            }
            function updateDt(){
                worker.postMessage({ type: 'updateDt', dt: gameState.dt });
            }
            function updateBallRadius(){
                worker.postMessage({ type: 'updateBallRadius', ballRadius: gameState.ballRadius });
            }
            function updateRadiusShow(){
                worker.postMessage({ type: 'updateRadiusShow', RadiusShow: gameState.RadiusShow });
            }
            function updateTHalf(){
                worker.postMessage({ type: 'updateTHalf', tHalf: gameState.tHalf });
            }
            function updateEveryThing(){
                updateRules();
                updateColors();
                updateMouseForce();
                updateCellSize();
                updateSetectGridDistance();
                updateUpdateInterval();
                updateBallRadius();
                updateRadiusShow();
                updateTHalf();
                updateDt();
            }

            // ÁÇ∫ÊªëÈº†ÂäõÈáèÊªëÂ°äÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            const mouseForceSlider = document.getElementById('mouse-force');
            const mouseForceNumber = document.getElementById('mouse-force-number');
            mouseForceSlider.addEventListener('input', () => {
                mouseForceNumber.value = mouseForceSlider.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceSlider.value) });
            });
            mouseForceNumber.addEventListener('input', () => {
                mouseForceSlider.value = mouseForceNumber.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceNumber.value) });
            });

            // ÁÇ∫Á∂≤Ê†ºÂ§ßÂ∞èÊªëÂ°äÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            const cellSizeSlider = document.getElementById('cell-size');
            const cellSizeNumber = document.getElementById('cell-size-number');
            cellSizeSlider.addEventListener('input', () => {
                cellSizeNumber.value = cellSizeSlider.value;
                gameState.gridData.cellSize = parseInt(cellSizeSlider.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeSlider.value) });
            }); 
            cellSizeNumber.addEventListener('input', () => {
                cellSizeSlider.value = cellSizeNumber.value;
                gameState.gridData.cellSize = parseInt(cellSizeNumber.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeNumber.value) });
            });

            // ÁÇ∫ÈÅ∏‰∏≠Á∂≤Ê†ºË∑ùÈõ¢ÊªëÂ°äÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            const setectGridDistanceSlider = document.getElementById('setectGridDistance');
            const setectGridDistanceNumber = document.getElementById('setectGridDistance-number');
            setectGridDistanceSlider.addEventListener('input', () => {
                setectGridDistanceNumber.value = setectGridDistanceSlider.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceSlider.value) });
            });
            setectGridDistanceNumber.addEventListener('input', () => {
                setectGridDistanceSlider.value = setectGridDistanceNumber.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceNumber.value) });
            })

            // ÁÇ∫Êõ¥Êñ∞ÈñìÈöîÊªëÂ°äÊ∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            const updateIntervalSlider = document.getElementById('updateInterval');
            const updateIntervalNumber = document.getElementById('updateInterval-number');
            const updateIntervalUnit = document.getElementById('updateInterval-unit');
            updateIntervalSlider.addEventListener('input', () => {
                updateIntervalNumber.value = updateIntervalSlider.value;
                updateIntervalUnit.selectedIndex = [...updateIntervalUnit.options].reduce((closest, option) => {
                    const distance = Math.abs(option.value - updateIntervalSlider.value);
                    return (distance < closest.distance) ? {option: option, distance: distance} : closest;
                }, {option: null, distance: Infinity}).option.index;
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalSlider.value) });
            });
            updateIntervalNumber.addEventListener('input', () => {
                updateIntervalSlider.value = updateIntervalNumber.value;
                updateIntervalUnit.selectedIndex = [...updateIntervalUnit.options].reduce((closest, option) => {
                    const distance = Math.abs(option.value - updateIntervalNumber.value);
                    return (distance < closest.distance) ? {option: option, distance: distance} : closest;
                }, {option: null, distance: Infinity}).option.index;
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalNumber.value) });
            }); 
            updateIntervalUnit.addEventListener('change', () => {
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(updateIntervalUnit.value) });
                updateIntervalSlider.value = updateIntervalUnit.value;
                updateIntervalNumber.value = updateIntervalUnit.value;
            });

            // Ê∑ªÂä†t_halfÊéßÂà∂‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('t-half').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half-number').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });

            document.getElementById('t-half-number').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });
            
            // Ê∑ªÂä†Á∂≤Ê†ºÈ°ØÁ§∫ÂàáÊèõ
            const showGridCheckbox = document.getElementById('showGrid');
            showGridCheckbox.addEventListener('change', () => {
                gameState.showGrid = showGridCheckbox.checked;
                worker.postMessage({ type: 'toggleGrid', show: gameState.showGrid });
            });

            const enableParticleAffcetRadiusShowCheckbox = document.getElementById('enableParticleAffcetRadiusShow');
            enableParticleAffcetRadiusShowCheckbox.addEventListener('change', () => {
                gameState.enableParticleAffcetRadiusShow = enableParticleAffcetRadiusShowCheckbox.checked;
                worker.postMessage({ type: 'toggleParticleAffcetRadiusShow', enable: gameState.enableParticleAffcetRadiusShow });
            });

            /*
            const isOneRadiusShowCheckbox = document.getElementById('isOneRadiusShow');
            isOneRadiusShowCheckbox.addEventListener('change', () => {
                isOneRadiusShow = isOneRadiusShowCheckbox.checked;
            });
            const isTwoRadiusShowCheckbox = document.getElementById('isTwoRadiusShow');
            isTwoRadiusShowCheckbox.addEventListener('change', () => {
                isTwoRadiusShow = isTwoRadiusShowCheckbox.checked;
            });
            const isThreeRadiusShowCheckbox = document.getElementById('isThreeRadiusShow');
            isThreeRadiusShowCheckbox.addEventListener('change', () => {
                isThreeRadiusShow = isThreeRadiusShowCheckbox.checked;
            });
            */
           
            function initializeMatrices(types, oldForceMatrix, oldDistanceMatrix) {
                forceMatrix = [];
                for (let i = 0; i < types; i++) {
                    forceMatrix.push([]);
                    for (let j = 0; j < types; j++) {
                        // Keep old force value if available, otherwise use 0
                        forceMatrix[i].push(oldForceMatrix && i < oldForceMatrix.length && j < oldForceMatrix[i].length ? 
                            oldForceMatrix[i][j] : Math.random()*2-1);
                    }
                }
                gameState.forceMatrix = forceMatrix;
                //console.log(`index.html: forceMatrix: ${forceMatrix}`);
                
                distanceMatrix = [];
                for (let i = 0; i < types; i++) {
                    distanceMatrix.push([]);
                    for (let j = 0; j < types; j++) {
                        // Keep old distance value if available, otherwise use 100
                        distanceMatrix[i].push(oldDistanceMatrix && i < oldDistanceMatrix.length && j < oldDistanceMatrix[i].length ?
                            oldDistanceMatrix[i][j] : 150);
                    }
                }
                gameState.distanceMatrix = distanceMatrix;
                //console.log(`index.html: distanceMatrix: ${distanceMatrix}`);
                
                particleGroups = [];
                for (let i = 0; i < types; i++) {
                    particleGroups.push([]);
                }
                gameState.particleGroups = particleGroups;
                //console.log(`index.html: particleGroups: ${particleGroups}`);
            }
            function initializeColors(types) {
                particleColors = [];
                for (let i = 0; i < types; i++) {
                    particleColors.push(`hsl(${i * 360 / types}, 100%, 50%)`);
                }
                gameState.particleColors = particleColors;
            }
            function initializeParticleCounts(types) {
                particleCounts = [];
                for (let i = 0; i < types; i++) {
                    particleCounts.push(gameState.particleCounts[i] || 250);
                }
                gameState.particleCounts = particleCounts;
            }
            // Ê∑ªÂä†Á≤íÂ≠êÈ°ûÂûãÊï∏ÈáèÁõ£ËÅΩÂô®
            document.getElementById('particle-types').addEventListener('input', (e) => {
                const types = parseInt(e.target.value);
                gameState.particleTypes = types;
                initializeColors(types);
                initializeMatrices(types, gameState.forceMatrix, gameState.distanceMatrix);
                initializeParticleCounts(types);
                updateParticleSystem();
                updateEveryThing();
                initGame();
            });

            // ‰øÆÊîπÂñÆÂÖÉÊ†ºÈÅ∏ÊìáÂäüËÉΩ
            canvas2d.addEventListener('click', (e) => {
                if (gameState.showGrid) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const cellX = Math.floor(x / gameState.gridData.cellSize);
                    const cellY = Math.floor(y / gameState.gridData.cellSize);
                    gameState.gridData.selectedCell = { x: cellX, y: cellY };
                    worker.postMessage({ 
                        type: 'selectCell', 
                        cell: gameState.gridData.selectedCell,
                    });
                    
                    // Áõ¥Êé•Êõ¥Êñ∞È°ØÁ§∫Ôºå‰ª•Êèê‰æõÂç≥ÊôÇÂèçÈ•ã
                    document.getElementById('selected-cell').textContent = `x: ${cellX}, y: ${cellY}`;
                }
                
                if (gameState.enableParticleAffcetRadiusShow) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // ÊâæÂà∞ÊúÄËøëÁöÑÁ≤íÂ≠ê
                    selectedParticle = particles.reduce((closest, particle) => {
                        const dx = particle.x - x;
                        const dy = particle.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return (distance < closest.distance)&&(distance < 10) ? { particle, distance } : closest;
                    }, { particle: null, distance: Infinity }).particle;
                    if (selectedParticle) {
                        gameState.selectedParticleId = selectedParticle.id;
                        gameState.selectedParticleType = selectedParticle.type;
                        document.getElementById('selectedParticleId').textContent = gameState.selectedParticleId;
                        // Ë´ãÊ±Ç worker Ë®àÁÆóÈôÑËøëÁöÑÁ≤íÂ≠ê
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: gameState.selectedParticleId,
                        });
                    } else {
                        document.getElementById('selectedParticleId').textContent = 'ÁÑ°';
                        gameState.selectedParticleId = null;
                        gameState.selectedParticleType = null;
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: null,
                        });
                        gameState.nearbyParticlesList = [];
                    }
                }
            });

            // ÂàùÂßãÂåñÈÅäÊà≤‰∏¶ÈñãÂßãÊõ¥Êñ∞Âæ™Áí∞
            updateParticleSystem();
            updateEveryThing();
            initGame();
            update();

            // ÂâµÂª∫Á≤íÂ≠êÈ°ûÂûãÊéßÂà∂ÁïåÈù¢
            function createParticleTypeControls(type, total, min, max, step, count) {
                const defaultColor = gameState.particleColors[type];
                
                return `
                    <div class="particle-type" data-type="${type}">
                        <h4>È°ûÂûã ${type + 1}</h4>
                        <div>
                            <label>Êï∏Èáè:</label>
                            <input type="range" class="particle-count" min="${min}" max="${max}" step="${step}" value="${count}">
                            <input type="number" class="particle-count-number" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${count}">
                        </div>
                        <div>
                            <label>È°èËâ≤:</label>
                            <div class="color-inputs">
                                <input type="color" class="particle-color" value="${hslToHex(defaultColor)}">
                                <span class="hsl-display">${defaultColor}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            function createMatrixTable(types, matrixType, min, max, step, matrix){
                let html = '<table class="matrix-container">';
                for (let i = 0; i < types; i++) {
                    html += `<tr>`;
                    for (let j = 0; j < types; j++) {
                        html += `<td><input type="number" class="matrix-input ${matrixType}" data-i="${i}" data-j="${j}" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${matrix[i][j]}"></td>`;
                    }
                    html += `</tr>`;
                }
                html += '</table>';
                return html;
            }

            // Êõ¥Êñ∞Á≤íÂ≠êÁ≥ªÁµ±
            function updateParticleSystem() {
                const types = gameState.particleTypes;
                const particleSettings = document.getElementById('particle-settings');
                const interactionMatrix = document.getElementById('interaction-matrix');
                const particleAffcetRadiusShow = document.getElementById('particle-affcet-radius-show');
                const particleNearbyParticles = document.getElementById('particle-nearby-particles');
                for (let i = 0; i < types; i++) {
                    gameState.RadiusShow[i] = gameState.RadiusShow[i] || true;
                };
                
                // Êõ¥Êñ∞Á≤íÂ≠êÈ°ûÂûãÊéßÂà∂
                particleSettings.innerHTML = '';
                for (let i = 0; i < types; i++) {
                    particleSettings.innerHTML += createParticleTypeControls(i, types, 0, 500, 10, gameState.particleCounts[i]);
                }
                
                // Êõ¥Êñ∞‰∫§‰∫íÁü©Èô£
                interactionMatrix.innerHTML = `
                    <div class="matrix-table">  
                        <h4>Á≤íÂ≠êÂºïÂäõ</h4>
                        <p class="description">Êï∏ÂÄºË∂äÂ§ßÔºåÁ≤íÂ≠êË∂äÂÆπÊòìËÅöÈõÜÂú®‰∏ÄËµ∑</p>
                        ${createMatrixTable(types, 'particle-force', -1, 1, 0.05, gameState.forceMatrix)}
                    </div>

                    <div class="matrix-table">
                        <h4>Á≤íÂ≠êË∑ùÈõ¢</h4>
                        <p class="description">Êï∏ÂÄºË∂äÂ§ßÔºåÂºïÂäõËåÉÂúçË∂äÂ§ß</p>
                        ${createMatrixTable(types, 'particle-distance', 10, 300, 10, gameState.distanceMatrix)}
                    </div>
                `;
                
                particleAffcetRadiusShow.innerHTML = '';
                
                for (let i = 0; i < types; i++) {
                    particleAffcetRadiusShow.innerHTML += `
                        <div class="particle-affcet-radius-show">
                            <label for="show-particle-affcet-radius-${i}">È°ØÁ§∫È°ûÂûã${i + 1}Á≤íÂ≠êÂΩ±ÈüøÁØÑÂúç</label>
                            <input type="checkbox" class="show-particle-affcet-radius" id="show-particle-affcet-radius-${i}" data-type="${i}" checked>
                        </div>
                    `;
                }
                particleNearbyParticles.innerHTML = "";
                for (let i = 0; i < types; i++) {
                    particleNearbyParticles.innerHTML += `
                        <p class="particle-nearby-particles" id="particle-nearby-particles-${i}">ÁØÑÂúçÂÖßÁöÑÈ°ûÂûã${i + 1}Á≤íÂ≠êÊï∏Èáè: N/A</p>
                    `;
                }
                
                // Ê∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
                setupParticleControlEventListeners();
                setupMatrixEventListeners();
                setupParticleAffcetRadiusShowEventListeners();
                // ÈáçÊñ∞ÂàùÂßãÂåñÁ≤íÂ≠êÁ≥ªÁµ±
                initGame();
            }
            // Ë®≠ÁΩÆÁ≤íÂ≠êÊéßÂà∂ÁöÑ‰∫ã‰ª∂Áõ£ËÅΩÂô®
            function setupParticleControlEventListeners() {
                // Êï∏ÈáèÊéßÂà∂
                document.querySelectorAll('.particle-count').forEach(input => {
                    const numberInput = input.parentElement.querySelector('.particle-count-number');
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    
                    input.addEventListener('input', (e) => {
                        const value = e.target.value;
                        numberInput.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                    
                    numberInput.addEventListener('input', (e) => {
                        const value = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        input.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                });

                // È°èËâ≤ÊéßÂà∂
                document.querySelectorAll('.particle-color').forEach(input => {
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    const hslDisplay = input.parentElement.querySelector('.hsl-display');
                    
                    input.addEventListener('input', (e) => {
                        const hsl = hexToHsl(e.target.value);
                        gameState.particleColors[type] = hsl;
                        hslDisplay.textContent = hsl;
                        worker.postMessage({
                            type: 'updateColors',
                            particleColors: gameState.particleColors
                        });
                    });
                });
            }
            // Ë®≠ÁΩÆÁü©Èô£Ëº∏ÂÖ•ÁöÑ‰∫ã‰ª∂Áõ£ËÅΩÂô®
            function setupMatrixEventListeners() {
                document.querySelectorAll('.particle-force').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const force = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        gameState.forceMatrix[i][j] = parseFloat(force);
                        updateRules();
                    });
                });

                document.querySelectorAll('.particle-distance').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        const distance = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        gameState.distanceMatrix[i][j] = parseFloat(distance);
                        updateRules();
                    });
                });
            }
            // Ë®≠ÁΩÆÁ≤íÂ≠êÂΩ±ÈüøÁØÑÂúçÈ°ØÁ§∫ÁöÑ‰∫ã‰ª∂Áõ£ËÅΩÂô®
            function setupParticleAffcetRadiusShowEventListeners() {
                document.querySelectorAll('.show-particle-affcet-radius').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const type = parseInt(e.target.dataset.type);
                        gameState.RadiusShow[type] = e.target.checked;
                        worker.postMessage({
                            type: 'updateRadiusShow',
                            RadiusShow: gameState.RadiusShow
                        });
                    });
                });
            }

            // HSL ËΩâ Hex È°èËâ≤ÂáΩÊï∏
            function hslToHex(hsl) {
                const match = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!match) return '#000000';
                
                const h = parseInt(match[1]) / 360;
                const s = parseInt(match[2]) / 100;
                const l = parseInt(match[3]) / 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            // Hex ËΩâ HSL È°èËâ≤ÂáΩÊï∏
            function hexToHsl(hex) {
                // ÁßªÈô§ # ËôüÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
                hex = hex.replace(/^#/, '');
                
                // Ëß£Êûê RGB ÂÄº
                const bigint = parseInt(hex, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                
                // ËΩâÊèõÁÇ∫ 0-1 ÁØÑÂúç
                const rr = r / 255;
                const gg = g / 255;
                const bb = b / 255;
                
                const max = Math.max(rr, gg, bb);
                const min = Math.min(rr, gg, bb);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case rr: h = (gg - bb) / d + (gg < bb ? 6 : 0); break;
                        case gg: h = (bb - rr) / d + 2; break;
                        case bb: h = (rr - gg) / d + 4; break;
                    }
                    
                    h /= 6;
                }
                
                return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
            }
        });
    </script>
</body>

</html>
