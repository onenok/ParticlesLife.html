<!--
 * Copyright (c) 2024 OneNok_HK
 * Licensed under the MIT License. See LICENSE file in the project root for full license information.
-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>particles life</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            background-color: black;
        }

        #controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            transition: right 0.3s ease-in-out;
            z-index: 1000;
        }

        #controls > div:not(#controls > div > div) {
            margin-top: 20px;
        }

        #controls.visible {
            right: 0;
        }

        #toggle-controls {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.7);
            transition: right 0.3s ease-in-out, opacity 0.3s ease;
            opacity: 0;
        }

        #toggle-controls:hover {
            opacity: 1;
        }

        /*canvas {
            border: 1px solid;
            border-color: rgb(63, 63, 63);
        }*/

        /* 按鈕組樣式 */
        .button-group {
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        h3 {
            color: #272727;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .button-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .styled-button {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            border: none;
            padding: 10px 20px;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .styled-button:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .styled-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* 性能數據顯示區域樣式 */
        #performance-data {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        #performance-data h3 {
            color: #fff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #performance-data p {
            color: #ffffff;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        #performance-data span {
            color: #5dff62;
            font-weight: bold;
        }

        /* 控制元素樣式 */
        input[type="range"] {
            width: 200px;
            height: 5px;
            border-radius: 5px;
            background: #4d4d4d;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
            background: #6e6e6e;
        }

        input[type="number"] {
            width: 70px;
            padding: 2px 5px;
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            font-size: 13px;
            height: 20px;
            box-sizing: border-box;
            margin-top: 5px;
        }

        input[type="number"]:focus,
        select:focus {
            border-color: #6e6e6e;
            outline: none;
            box-shadow: 0 0 5px rgba(110, 110, 110, 0.5);
        }

        select {
            padding: 2px 5px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4d4d4d;
            border-radius: 4px;
            color: #ffffff;
            font-size: 13px;
            height: 20px;
        }

        /* 標籤樣式 */
        label {
            color: #d0d0d0;
            margin-right: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 複選框樣式 */
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 10px;
        }

        /* 一般標籤和文字的默認顏色 */
        label {
            color: #2e2e2e;
        }

        /* 一般段落文字 */
        p {
            color: #2e2e2e;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 有特定背景的元素保持白色文字 */
        #performance-data p {
            color: #ffffff;
        }

        /* 保持按鈕文字為白色，因為按鈕有深色背景 */
        .styled-button {
            color: #d0d0d0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 性能數據區域保持白色文字 */
        #performance-data h3,
        #performance-data p {
            color: #ffffff;
        }

        /* 性能數據中的數值保持綠色 */
        #performance-data span {
            color: #5dff62;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* 切換開關容器 */
        .toggle-container {
            margin: 10px 0;
            display: flex;
        }

        /* 標籤樣式 */
        .toggle-label {
            width: fit-content;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            pointer-events: none;
        }

        /* 切換開關外觀 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        /* 隱藏原始複選框，但保持在滑塊位置 */
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1; /* 確保複選框在最上層 */
            margin: 0; /* 移除默認邊距 */
        }

        /* 滑塊樣式 */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #4d4d4d;
            transition: .3s;
            border-radius: 24px;
            pointer-events: none; /* 確保滑塊不會干擾點擊事件 */
        }

        /* 滑塊的圓形按鈕 */
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: #d0d0d0;
            transition: .3s;
            border-radius: 50%;
        }

        /* 選中狀態的樣式 */
        input:checked + .slider {
            background-color: #4CAF50;
        }

        /* 滑塊懸停效果 */
        .slider:hover {
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        /* 選中狀態下圓形按鈕的位置 */
        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: #ffffff;
        }

        /* 粒子規則容器（新增樣式） */
        .rules-container {
            background: rgba(0, 0, 0, 0.2); 
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        .rules-container > div:not(.no-background) {
            background: rgba(0, 0, 0, 0.1); 
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        .matrix-container {
            overflow-x: auto;
            display: flex;
        }

        .matrix-container input[type="number"] {
            width: 100%;
            min-width: 10px;
            padding: 2px;
            border: none;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }


        .particle-type {
            background: rgba(0, 0, 0, 0.1);
            padding: 0 5px 5px 5px;
            border-radius: 5px;
        }
        .description {
            color: #222222;
            font-size: 12px;
            margin: 0;
        }

        .matrix-table {
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .color-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-inputs input[type="color"],
        .color-inputs input[type="range"] {
            flex: 1;
        }
        .no-hit-box {
            pointer-events: none;
            position: absolute;
            background: none;
            border: none;
            margin: 4%;
            padding: 2px 5px;
            width: 70px;
            height: 20px;
            box-sizing: border-box;
            font-size: 13px;
            color: #2e2e2e;
            left: 0;
            top: 0;
            color: white;
        }

        .input-container {
            position: relative;
            display: inline-block;
        }

        .styled-select {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            border: none;
            padding: 2px 15px;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            width: 200px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 20px;
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin-bottom: 3px;
        }

        .styled-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.5);
        }

        .styled-select option {
            background: #2a2a2a;
            color: #ffffff;
            padding: 8px;
        }

        .styled-select option:disabled {
            color: #666666;
            font-style: italic;
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            color: #2e2e2e;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <button id="toggle-controls">☰</button>
    <div id="controls">
        <div class="rules-container">
            <h3>📋 粒子系統設置</h3>
            <div class="control-section">
                <h3>基本設置</h3>
                <div>
                    <label for="particle-types">粒子類型數量:</label>
                    <input type="number" id="particle-types" min="1" max="10" value="3">
                </div>
            </div>
            
            <div id="particle-settings" class="no-background">
                <!-- 動態生成的粒子設置 -->
            </div>
            
            <div id="interaction-matrix" class="no-background">
                <!-- 動態生成的交互矩陣 -->
            </div>
        </div>
        
        <div class="toggle-container">
            <label for="isThrough" class="toggle-label">🔁 無邊界模式</label>
            <div class="toggle-switch">
                <input type="checkbox" id="isThrough">
                <span class="slider"></span>
            </div>
        </div>

        <!-- 將按鈕組重組織並添加樣式 -->
        <div class="button-group">
            <!-- 基本操作按鈕 -->
            <div class="control-section">
                <h3>🎮 基本操作</h3>
                <div class="button-container">
                    <button id="randomize-button" class="styled-button">🎲 隨機化所有值(r)</button>
                    <button id="restart-button" class="styled-button">🔄 重新開始遊戲(s)</button>
                    <button id="randomize-and-restart-button" class="styled-button">🎯 隨機化並重新開始(f)</button>
                </div>
            </div>

            <!-- 規則導入導出按鈕 -->
            <div class="control-section">
                <h3>💾 規則管理</h3>
                <div class="button-container">
                    <button id="export-rules" class="styled-button">📤 匯出規則</button>
                    <button id="import-rules" class="styled-button">📥 導入規則</button>
                    <button id="import-rules-and-restart" class="styled-button">📋 導入規則並重新開始</button>
                </div>
            </div>
            <input type="file" id="import-file" style="display: none;">
        </div>

        <!-- 添加滑鼠吸引力滑塊 -->
        <div>
            <label for="mouse-force">滑鼠吸引力:</label>
            <input type="range" id="mouse-force" min="0" max="200" step="0.1" value="100">
            <input type="number" id="mouse-force-number" min="0" max="200" step="0.1" value="100">
        </div>
        <p class="description">按下 "x" 鍵可以持續吸引</p>
        <p class="description">按下 "z" 鍵可以鎖定吸力位置</p>
        <div class="control-section">
            <h3>物理參數</h3>
            <div class="control-item">
                <label for="t-half">摩擦半衰期(秒):</label>
                <input type="range" id="t-half" min="0.001" max="0.1" step="0.001" value="0.020">
                <input type="number" id="t-half-number" min="0.001" max="0.1" step="0.001" value="0.020">
            </div>
        </div>

        <div>
            <label for="updateInterval">最大更新次數上限:</label>
            <input type="range" id="updateInterval" min="0" max="1000" step="1" value="0">
            <div class="input-container">
                <input type="number" id="updateInterval-number" min="0" max="1000" step="1" value="0">
                <input class="no-hit-box" type="text" id="updateInterval-text" value="無上限" readonly>
            </div>
            <p class="description">UPS: Update Per Second，每秒更新次數</p>
            <p class="description">注意: 此功能用於鎖定更新間隔上限，如果電腦不能運行到那麼短的更新間隔，那麼你的電腦就無法運行到那麼短的更新間隔。</p>
        </div>
        <div class="toggle-container">
            <label for="isUsingGrid" class="toggle-label">𝄜 使用網格分割(g)</label>
            <div class="toggle-switch">
                <input type="checkbox" id="isUsingGrid">
                <span class="slider"></span>
            </div>
        </div>
        <div class="control-section">
            <label for="threadMode" class="control-label">🔄 運算模式 (m)</label>
            <select id="threadMode" class="styled-select">
                <option value="singlethread">單線程模式</option>
                <option value="multithread">多線程模式</option>
                <option value="multithread_gpu" disabled>GPU 加速模式 (開發中)</option>
                <option value="multithread_wasm" disabled>WebAssembly 模式 (開發中)</option>
            </select>
            <p class="description">選擇不同的運算模式以優化性能</p>
        </div>

        <!-- 在控制面板中添加性能數據顯示 -->
        <div id="performance-data">
            <h3>性能數據</h3>
            <p>渲染FPS: <span id="fps"></span><br>(這並不是遊戲每秒更新次數。)</p>
            <p>遊戲UPS: <span id="gameUPS"></span><br>(這是遊戲每秒更新次數。)</p>
            <p>粒子更新總時間: 
                <br>當前: <span id="total-time"></span> ms 
                <br>平均: <span id="total-time-average"></span> ms
                <br>最大: <span id="total-time-max"></span> ms
            </p>
            <p>粒子更新時間加法顯示:
                <br>網格重置時間 + 取得附近粒子時間 + 重力影響計算時間 + 更新位置時間 + 粒子碰撞計算時間 + 粒子影響範圍計算時間
                <br><span id="total-time-add-show"></span>
            </p>
            <p>網格重置時間: 
                <br>當前: <span id="grid-reset-time"></span> ms 
                <br>平均: <span id="grid-reset-time-average"></span> ms
                <br>最大: <span id="grid-reset-time-max"></span> ms
                <br>單次平均: <span id="grid-reset-time-single-average"></span> ms
                <br>每更新執行次數: <span id="grid-reset-time-run-per-update"></span> 次
            </p>
            <p>取得附近粒子時間: 
                <br>當前: <span id="get-nearby-time"></span> ms 
                <br>平均: <span id="get-nearby-time-average"></span> ms
                <br>最大: <span id="get-nearby-time-max"></span> ms
                <br>單次平均: <span id="get-nearby-time-single-average"></span> ms
                <br>每更新執行次數: <span id="get-nearby-time-run-per-update"></span> 次
            </p>
            <p>重力影響計算時間: 
                <br>當前: <span id="g-Affect-Calc-time"></span> ms 
                <br>平均: <span id="g-Affect-Calc-time-average"></span> ms
                <br>最大: <span id="g-Affect-Calc-time-max"></span> ms
                <br>單個粒子平均: <span id="g-Affect-Calc-time-single-average"></span> ms
                <br>每更新執行次數: <span id="g-Affect-Calc-time-run-per-update"></span> 次
                <br>已跳過的粒子數量: <span id="particleSkippedCountsTimes"></span> 次
                <br>有效粒子數量: <span id="particleValidCountsTimes"></span> 次
            </p>
            <p>更新位置時間: 
                <br>當前: <span id="position-update-time"></span> ms 
                <br>平均: <span id="position-update-time-average"></span> ms
                <br>最大: <span id="position-update-time-max"></span> ms
                <br>單次平均: <span id="position-update-time-single-average"></span> ms
                <br>每更新執行次數: <span id="position-update-time-run-per-update"></span> 次
            </p>
            <p>粒子碰撞計算時間: 
                <br>當前: <span id="particle-collision-time"></span> ms 
                <br>平均: <span id="particle-collision-time-average"></span> ms
                <br>最大: <span id="particle-collision-time-max"></span> ms
                <br>單次平均: <span id="particle-collision-time-single-average"></span> ms
                <br>每更新執行次數: <span id="particle-collision-time-run-per-update"></span> 次
            </p>
            <p>粒子影響範圍計算時間: 
                <br>當前: <span id="Particle-Affect-Calc-time"></span> ms 
                <br>平均: <span id="Particle-Affect-Calc-time-average"></span> ms
                <br>最大: <span id="Particle-Affect-Calc-time-max"></span> ms
            </p>
        </div>
        
        <!-- 在控制面板中添加新的控制元素 -->
        <div class="grid-controls">
            <h3>⌗ 網格設置</h3>
            <div class="toggle-container">
                <label for="showGrid" class="toggle-label">🔲 顯示網格</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="showGrid">
                    <span class="slider"></span>
                </div>
            </div>
            <div>
                <p>當前所選單元格: <span id="selected-cell"></span></p>
                <p>網格寬度: <span id="grid-width"></span></p>
                <p>網格高度: <span id="grid-height"></span></p>
            </div>
            <div>
                <label for="setectGridDistance">模擬作用範圍: </label>
                <input type="range" id="setectGridDistance" min="10" max="500" step="10" value="300">
                <input type="number" id="setectGridDistance-number" min="10" max="500" step="10" value="300">
                <p class="description">相當於: <span id="grid-radius-cells">6</span> 個單元格的半徑</p>
            </div>
            <div>
                <label for="cell-size">網格大小:</label>
                <input type="range" id="cell-size" min="40" max="200" step="1" value="50">
                <input type="number" id="cell-size-number" min="40" max="200" step="1" value="50">
            </div>
        </div>

        <!-- 在性能數據顯示區域之後添加以下代碼 -->
        <div>
            <h3>☢️ 粒子影響範圍顯示</h3>
            <div class="toggle-container">
                <label for="enableParticleAffcetRadiusShow" class="toggle-label">啟用粒子影響範圍顯示: </label>
                <div class="toggle-switch">
                    <input type="checkbox" id="enableParticleAffcetRadiusShow">
                    <span class="slider"></span>
                </div>
            </div>
            <div id="particle-affcet-radius-show" class="no-background">
                <!-- 動態生成的粒子影響範圍顯示設置 -->
            </div>
            <div>
                <p>選中的粒子ID: <span id="selectedParticleId">無</span></p>
                <p>選中的粒子屬性: <span id="selectedParticleProperty"></span></p>
                <div id="particle-nearby-particles" class="no-background">
                    <!-- 動態生成的粒子範圍內的{i}號粒子數量 -->
                </div>
            </div>
        </div>
        <div>
            <p style="font-size: 1.2em; font-weight: bold; color: #ff6b6b; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); margin: 15px 0;">💬 交流與反饋</p>
            <a href="https://github.com/onenok/ParticlesLife.html/issues" style="text-decoration: none; display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 6px; background: #24292e; color: white; width: fit-content; transition: background 0.2s;">
                <svg height="24" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="24" fill="currentColor">
                    <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
                </svg>
                <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">GitHub Issues</span>
            </a>
        </div>
    </div>
    <canvas id="board2d"></canvas>

    <script>
        // 創建 Web Worker
        let worker = new Worker('particleWorker_Singlethread.js');
        // 用戶可控制數據的初始化
        const gameState = {
            // 粒子系統基本設置
            isUsingGrid: false,
            threadMode: 'singlethread',
            particleTypes: 3,
            particleCounts: [250, 250, 250],
            particleColors: [
                'hsl(0, 100%, 50%)',   // 紅色
                'hsl(120, 100%, 50%)', // 綠色
                'hsl(240, 100%, 50%)'  // 藍色
            ],
            particleGroups: [],
            // 交互矩陣
            forceMatrix: [
                [1, 0.5, 0],
                [0, 1, 0.5],
                [0.5, 0, 1]
            ],
            distanceMatrix: [
                [300, 300, 300],
                [300, 300, 300],
                [300, 300, 300]
            ],
            
            // 物理參數
            tHalf: 0.020,         // 摩擦半衰期
            dt: 1/144,           // 時間步長
            
            // 顯示設置
            isThrough: false,     // 無邊界模式
            showGrid: false,      // 顯示網格
            gridData: {
                cellSize: 50,
                width: 0,
                height: 0,
                selectedCell: null,
                radiusCells: 0,
                nearbyCells: [],
                nearbyCellsSkipped: []
            },
            
            // 滑鼠交互
            mouseForce: 100,
            
            // 其他設置
            setectGridDistance: 300,
            enableParticleAffcetRadiusShow: false,
            selectedParticleId: null,
            selectedParticleType: null,
            nearbyParticlesList: [],
            ballRadius: 1.5,
            RadiusShow: [true, true, true],
            // 更新控制
            updateInterval: 0,    // 0 為無上限
            isMovingCanvas: false
        };
        document.addEventListener('DOMContentLoaded', () => {
            const canvas2d = document.getElementById("board2d");
            const ctx = canvas2d.getContext("2d");

            // 移除 WebGL 相關變量
            /*
            let useWebGL = false; // 保留這個變量，但始終為 false
            */

            function updateCanvasSize() {
                const controlPanel = document.getElementById('controls');
                const isPanelVisible = controlPanel.classList.contains('visible');
                const width = document.documentElement.clientWidth - (isPanelVisible ? 300 : 0);
                const height = document.documentElement.clientHeight;

                canvas2d.width = width;
                canvas2d.height = height;

                // 設置 Canvas 樣式
                canvas2d.style.position = 'absolute';
                canvas2d.style.left = '0';
                canvas2d.style.top = '0';

                worker.postMessage({ type: 'updateCanvasSize', width, height });
            }

            function draw(particles, gridData) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);
                if (gameState.showGrid && gridData) {
                    drawGrid(ctx, gridData);
                }

                
                particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, gameState.ballRadius, 0, Math.PI * 2);
                    
                    if (gameState.enableParticleAffcetRadiusShow) {
                        if (gameState.selectedParticleId === null) {
                            ctx.fillStyle = 'gray';
                            ctx.fill();
                            ctx.closePath();
                        }else if (p.id === gameState.selectedParticleId) {
                            let isXOverflow = false;
                            let isYOverflow = false;
                            let newx = p.x;
                            let newy = p.y;
                            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                            ctx.fill();
                            ctx.closePath();
                            for (let i = 0; i < gameState.RadiusShow.length; i++) {
                                if (gameState.RadiusShow[i]) {
                                    hsl = gameState.particleColors[i];
                                    h = hsl.match(/hsl\((\d+),\s*\d+%,\s*\d+%\)/)[1];
                                    hsla = `hsla(${h}, 100%, 50%, 0.3)`;
                                    radius = gameState.distanceMatrix[gameState.selectedParticleType][i];
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                                    ctx.fillStyle = hsla;
                                    ctx.fill();
                                    ctx.closePath();
                                    if (throughCheckbox.checked) {
                                        isXOverflow = false;
                                        isYOverflow = false;
                                        newx = p.x;
                                        newy = p.y;
                                        if ((p.x < radius || p.x > canvas2d.width - radius)){
                                            isXOverflow = true;
                                            newx = p.x < radius ? p.x + canvas2d.width : p.x - canvas2d.width;
                                            ctx.beginPath();
                                            ctx.arc(newx, p.y, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if ((p.y < radius || p.y > canvas2d.height - radius)){
                                            isYOverflow = true;
                                            newy = p.y < radius ? p.y + canvas2d.height : p.y - canvas2d.height;
                                            ctx.beginPath();
                                            ctx.arc(p.x, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                        if (isXOverflow && isYOverflow) {
                                            ctx.beginPath();
                                            ctx.arc(newx, newy, radius, 0, Math.PI * 2);
                                            ctx.fillStyle = hsla;
                                            ctx.fill();
                                            ctx.closePath();
                                        }
                                    }
                                }
                            }
                        } else { 
                            if (gameState.RadiusShow[p.type]) {
                                ctx.fillStyle = (gameState.nearbyParticlesList[p.type]||[]).includes(p) ? p.color : 'gray';
                                ctx.fill();
                                ctx.closePath();
                            }
                        }
                    } else {
                        ctx.fillStyle = p.isOutside ? 'white' : p.color;
                        ctx.fill();
                        ctx.closePath();
                    }
                });
            }

            function drawGrid(ctx, gridData) {
                const { cellSize, width, height, selectedCell, nearbyCells, nearbyCellsSkipped, radiusCells } = gridData;
                const canvasWidth = canvas2d.width;
                const canvasHeight = canvas2d.height;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                // 繪製垂直線
                for (let x = 0; x <= width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * cellSize, 0);
                    ctx.lineTo(x * cellSize, Math.min(height * cellSize, canvasHeight));
                    ctx.stroke();
                }

                // 繪製水平線
                for (let y = 0; y <= height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * cellSize);
                    ctx.lineTo(Math.min(width * cellSize, canvasWidth), y * cellSize);
                    ctx.stroke();
                }

                // 繪製選中的單元格和附近的單元格
                if (selectedCell) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                    ctx.fillRect(selectedCell.x * cellSize, selectedCell.y * cellSize, cellSize, cellSize);

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    nearbyCells.forEach(cell => {
                        ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                        const text = `${Math.sqrt(cell.cellRadiusNotSqrtYet).toFixed(2)}格`;
                        ctx.font = `${2*cellSize/text.length}px serif`;
                        ctx.textBaseline = "middle";
                        ctx.textAlign = "center";
                        ctx.strokeText(text, cellSize*(cell.x+1/2), cellSize*(cell.y+1/2), cellSize);
                    });
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    nearbyCellsSkipped.forEach(cell => {
                        ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
                        const text = `${Math.sqrt(cell.cellRadiusNotSqrtYet).toFixed(2)}格`;
                        ctx.font = `${2*cellSize/text.length}px serif`;
                        ctx.textBaseline = "middle";
                        ctx.textAlign = "center";
                        ctx.strokeText(text, cellSize*(cell.x+1/2), cellSize*(cell.y+1/2), cellSize);
                    });
                }
            }

            function drawWarningCanvasMoving() {
                const canvasWidth = canvas2d.width;
                const canvasHeight = canvas2d.height;
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)'; // Yellow background like console.warn
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.font = 'bold 20px monospace'; // Console-like font
                ctx.fillStyle = '#000'; // Dark text
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                ctx.fillText('⚠️ 畫布正在移動中', canvasWidth/2, canvasHeight/2, canvasWidth); // Added warning emoji and using fillText for solid text
            }

            // 添加 FPS 計算相關變量
            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 0;
            let gameFPS = 0;

            let particles = [];
            let performanceDataLocal = {
                updateIntervalCountsTimes: 0,
                totalTimeAll: [],
                totalTimeMax: 0,
                totalTimeAverage: 0,
                gridResetTimeAll: [],
                gridResetTimeMax: 0,
                gridResetTimeAverage: 0,
                getNearbyTimeAll: [],
                getNearbyTimeMax: 0,
                getNearbyTimeAverage: 0,
                gAffectCalcTimeAll: [],
                gAffectCalcTimeMax: 0,
                gAffectCalcTimeAverage: 0,
                positionUpdateTimeAll: [],
                positionUpdateTimeMax: 0,
                positionUpdateTimeAverage: 0,
                particleCollisionTimeAll: [],
                particleCollisionTimeMax: 0,
                particleCollisionTimeAverage: 0,
                ParticleAffcetCalcTimeAll: [],
                ParticleAffcetCalcTimeMax: 0,
                ParticleAffcetCalcTimeAverage: 0
            };
            let performanceData = {
                totalTime: 0,
                gridResetTime: 0,
                gridResetAndAddCountsTimes: 0,
                getNearbyTime: 0,
                getNearbyCountsTimes: 0,
                gAffectCalcTime: 0,
                gAffectCalcCountsTimes: 0,
                particleSkippedCountsTimes: 0,
                positionUpdateTime: 0,
                positionUpdateCountsTimes: 0,
                ParticleAffcetCalcTime: 0,
                particleCollisionTime: 0,
                particleCollisionCountsTimes: 0,
            };
            
            // 初始化遊戲函數修改
            function initGame() {
                Object.keys(performanceDataLocal).forEach(key => {
                    if (performanceDataLocal[key] instanceof Array) {
                        performanceDataLocal[key] = [];
                    } else {
                        performanceDataLocal[key] = 0;
                    }
                });
                worker.postMessage({
                    type: 'init',
                    particleCounts: gameState.particleCounts,
                    canvasWidth: canvas2d.width,
                    canvasHeight: canvas2d.height,
                    particleColors: gameState.particleColors,
                    particleTypes: gameState.particleTypes,
                    performanceData: performanceData,
                    cellSize: gameState.gridData.cellSize,
                    ballRadius: gameState.ballRadius  // 添加 ballRadius 參數
                });
            }

            // 初始化 canvas 尺寸
            updateCanvasSize();

            // 監聽視窗大小變化
            window.addEventListener("resize", updateCanvasSize);


            let totalTimeAverageUpdateMs = 1000;
            let gridResetTimeAverageUpdateMs = 1000;
            let getNearbyTimeAverageUpdateMs = 1000;
            let gAffectCalcTimeAverageUpdateMs = 1000;
            let positionUpdateTimeAverageUpdateMs = 1000;
            let ParticleAffcetCalcTimeAverageUpdateMs = 1000;
            let particleCollisionTimeAverageUpdateMs = 1000;
            let totalTimeAverageUpdateLastTime = 0;
            let gridResetTimeAverageUpdateLastTime = 0;
            let getNearbyTimeAverageUpdateLastTime = 0;
            let gAffectCalcTimeAverageUpdateLastTime = 0;
            let positionUpdateTimeAverageUpdateLastTime = 0;
            let ParticleAffcetCalcTimeAverageUpdateLastTime = 0;
            let particleCollisionTimeAverageUpdateLastTime = 0;
            function update() {
                // 更新所選單元格的顯示
                if (gameState.gridData.selectedCell) {
                    document.getElementById('selected-cell').textContent = `x: ${gameState.gridData.selectedCell.x}, y: ${gameState.gridData.selectedCell.y}`;
                } else {
                    document.getElementById('selected-cell').textContent = '無';
                }
                draw(particles, gameState.gridData);
                if (gameState.isMovingCanvas) {
                    drawWarningCanvasMoving();
                }
                if (performanceData.totalTime > performanceDataLocal.totalTimeMax) {
                    performanceDataLocal.totalTimeMax = performanceData.totalTime;
                }
                if (performanceData.gridResetTime > performanceDataLocal.gridResetTimeMax){
                    performanceDataLocal.gridResetTimeMax = performanceData.gridResetTime;
                }
                if (performanceData.getNearbyTime > performanceDataLocal.getNearbyTimeMax){
                    performanceDataLocal.getNearbyTimeMax = performanceData.getNearbyTime;
                }
                if (performanceData.gAffectCalcTime > performanceDataLocal.gAffectCalcTimeMax){
                    performanceDataLocal.gAffectCalcTimeMax = performanceData.gAffectCalcTime;
                }
                if (performanceData.positionUpdateTime > performanceDataLocal.positionUpdateTimeMax){
                    performanceDataLocal.positionUpdateTimeMax = performanceData.positionUpdateTime;
                }
                if (performanceData.particleCollisionTime > performanceDataLocal.particleCollisionTimeMax){
                    performanceDataLocal.particleCollisionTimeMax = performanceData.particleCollisionTime;
                }
                if (performanceData.ParticleAffcetCalcTime > performanceDataLocal.ParticleAffcetCalcTimeMax){
                    performanceDataLocal.ParticleAffcetCalcTimeMax = performanceData.ParticleAffcetCalcTime;
                }
                performanceDataLocal.totalTimeAll.push(performanceData.totalTime);
                performanceDataLocal.gridResetTimeAll.push(performanceData.gridResetTime);
                performanceDataLocal.getNearbyTimeAll.push(performanceData.getNearbyTime);
                performanceDataLocal.gAffectCalcTimeAll.push(performanceData.gAffectCalcTime);
                performanceDataLocal.positionUpdateTimeAll.push(performanceData.positionUpdateTime);
                performanceDataLocal.particleCollisionTimeAll.push(performanceData.particleCollisionTime);
                performanceDataLocal.ParticleAffcetCalcTimeAll.push(performanceData.ParticleAffcetCalcTime);
                // 更新性能數據顯示
                document.getElementById('total-time').textContent = performanceData.totalTime.toFixed(2);
                if (performance.now() - totalTimeAverageUpdateLastTime >= totalTimeAverageUpdateMs) {
                    performanceDataLocal.totalTimeAverage = performanceDataLocal.totalTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.totalTimeAll.length;
                    document.getElementById('total-time-average').textContent = performanceDataLocal.totalTimeAverage.toFixed(2);
                    performanceDataLocal.totalTimeAll = [];  
                    totalTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('total-time-max').textContent = performanceDataLocal.totalTimeMax.toFixed(2);
                
                document.getElementById('grid-reset-time').textContent = performanceData.gridResetTime.toFixed(2);  
                if (performance.now() - gridResetTimeAverageUpdateLastTime >= gridResetTimeAverageUpdateMs) {
                    performanceDataLocal.gridResetTimeAverage = performanceDataLocal.gridResetTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.gridResetTimeAll.length;
                    document.getElementById('grid-reset-time-average').textContent = performanceDataLocal.gridResetTimeAverage.toFixed(2);
                    performanceDataLocal.gridResetTimeAll = [];
                    gridResetTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('grid-reset-time-max').textContent = performanceDataLocal.gridResetTimeMax.toFixed(2);
                document.getElementById('grid-reset-time-single-average').textContent = performanceData.gridResetAndAddCountsTimes > 0 ? ((performanceDataLocal.gridResetTimeAverage/performanceData.gridResetAndAddCountsTimes).toFixed(4)) : '不適用';
                document.getElementById('grid-reset-time-run-per-update').textContent = performanceData.gridResetAndAddCountsTimes;

                document.getElementById('get-nearby-time').textContent = performanceData.getNearbyTime.toFixed(2);
                if (performance.now() - getNearbyTimeAverageUpdateLastTime >= getNearbyTimeAverageUpdateMs) {
                    performanceDataLocal.getNearbyTimeAverage = performanceDataLocal.getNearbyTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.getNearbyTimeAll.length;
                    document.getElementById('get-nearby-time-average').textContent = performanceDataLocal.getNearbyTimeAverage.toFixed(2);
                    performanceDataLocal.getNearbyTimeAll = [];
                    getNearbyTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('get-nearby-time-max').textContent = performanceDataLocal.getNearbyTimeMax.toFixed(2);
                document.getElementById('get-nearby-time-single-average').textContent = performanceData.getNearbyCountsTimes > 0 ? ((performanceDataLocal.getNearbyTimeAverage/performanceData.getNearbyCountsTimes).toFixed(4)) : '不適用';
                document.getElementById('get-nearby-time-run-per-update').textContent = performanceData.getNearbyCountsTimes;

                document.getElementById('g-Affect-Calc-time').textContent = performanceData.gAffectCalcTime.toFixed(2);
                if (performance.now() - gAffectCalcTimeAverageUpdateLastTime >= gAffectCalcTimeAverageUpdateMs) {
                    performanceDataLocal.gAffectCalcTimeAverage = performanceDataLocal.gAffectCalcTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.gAffectCalcTimeAll.length;
                    document.getElementById('g-Affect-Calc-time-average').textContent = performanceDataLocal.gAffectCalcTimeAverage.toFixed(2);
                    performanceDataLocal.gAffectCalcTimeAll = [];
                    gAffectCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('g-Affect-Calc-time-max').textContent = performanceDataLocal.gAffectCalcTimeMax.toFixed(2);
                document.getElementById('g-Affect-Calc-time-single-average').textContent = performanceData.gAffectCalcCountsTimes > 0 ? ((performanceDataLocal.gAffectCalcTimeAverage/performanceData.gAffectCalcCountsTimes).toFixed(6)) : '不適用';
                document.getElementById('g-Affect-Calc-time-run-per-update').textContent = performanceData.gAffectCalcCountsTimes;
                document.getElementById('particleSkippedCountsTimes').textContent = performanceData.particleSkippedCountsTimes;
                document.getElementById('particleValidCountsTimes').textContent = performanceData.gAffectCalcCountsTimes - performanceData.particleSkippedCountsTimes;

                document.getElementById('position-update-time').textContent = performanceData.positionUpdateTime.toFixed(2);
                if (performance.now() - positionUpdateTimeAverageUpdateLastTime >= positionUpdateTimeAverageUpdateMs) {
                    performanceDataLocal.positionUpdateTimeAverage = performanceDataLocal.positionUpdateTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.positionUpdateTimeAll.length;
                    document.getElementById('position-update-time-average').textContent = performanceDataLocal.positionUpdateTimeAverage.toFixed(2);
                    performanceDataLocal.positionUpdateTimeAll = [];
                    positionUpdateTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('position-update-time-max').textContent = performanceDataLocal.positionUpdateTimeMax.toFixed(2);
                document.getElementById('position-update-time-single-average').textContent = performanceData.positionUpdateCountsTimes > 0 ? ((performanceDataLocal.positionUpdateTimeAverage/performanceData.positionUpdateCountsTimes).toFixed(4)) : '不適用';
                document.getElementById('position-update-time-run-per-update').textContent = performanceData.positionUpdateCountsTimes;

                document.getElementById('particle-collision-time').textContent = performanceData.particleCollisionTime.toFixed(2);
                if (performance.now() - particleCollisionTimeAverageUpdateLastTime >= particleCollisionTimeAverageUpdateMs) {
                    performanceDataLocal.particleCollisionTimeAverage = performanceDataLocal.particleCollisionTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.particleCollisionTimeAll.length;
                    document.getElementById('particle-collision-time-average').textContent = performanceDataLocal.particleCollisionTimeAverage.toFixed(2);
                    performanceDataLocal.particleCollisionTimeAll = [];
                    particleCollisionTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('particle-collision-time-max').textContent = performanceDataLocal.particleCollisionTimeMax.toFixed(2);
                document.getElementById('particle-collision-time-single-average').textContent = performanceData.particleCollisionCountsTimes > 0 ? ((performanceDataLocal.particleCollisionTimeAverage/performanceData.particleCollisionCountsTimes).toFixed(4)) : '不適用';
                document.getElementById('particle-collision-time-run-per-update').textContent = performanceData.particleCollisionCountsTimes;

                document.getElementById('Particle-Affect-Calc-time').textContent = performanceData.ParticleAffcetCalcTime.toFixed(2);
                if (performance.now() - ParticleAffcetCalcTimeAverageUpdateLastTime >= ParticleAffcetCalcTimeAverageUpdateMs) {
                    performanceDataLocal.ParticleAffcetCalcTimeAverage = performanceDataLocal.ParticleAffcetCalcTimeAll.reduce((a, b) => a + b, 0) / performanceDataLocal.ParticleAffcetCalcTimeAll.length;
                    document.getElementById('Particle-Affect-Calc-time-average').textContent = performanceDataLocal.ParticleAffcetCalcTimeAverage.toFixed(2);
                    performanceDataLocal.ParticleAffcetCalcTimeAll = [];
                    ParticleAffcetCalcTimeAverageUpdateLastTime = performance.now();
                }
                document.getElementById('Particle-Affect-Calc-time-max').textContent = performanceDataLocal.ParticleAffcetCalcTimeMax.toFixed(2);

                // 更新選中粒子的屬性顯示
                if (gameState.enableParticleAffcetRadiusShow){
                    const propertyElement = document.getElementById('selectedParticleProperty');
                    if (gameState.selectedParticleId !== null && particles.length > 0) {
                        const selectedParticle = particles.find(p => p.id === gameState.selectedParticleId);
                        if (selectedParticle) {
                            const properties = [
                                `\n`,
                                `類型: ${selectedParticle.type + 1}`,
                                `位置: (${selectedParticle.x.toFixed(2)}, ${selectedParticle.y.toFixed(2)})`,
                                `網格位置: (${selectedParticle.gridX}, ${selectedParticle.gridY})`,
                                `速度: (${selectedParticle.vx.toFixed(2)}, ${selectedParticle.vy.toFixed(2)})`,
                                `顏色: ${selectedParticle.color}`,
                                `是否在邊界外: ${selectedParticle.isOutside ? '是' : '否'}`
                            ];
                            propertyElement.innerHTML = properties.join('<br>');
                        } else {
                            propertyElement.textContent = '找不到選中的粒子';
                        }
                    } else {
                        propertyElement.textContent = '未選中粒子';
                    }
                }

                // 計算並顯示 FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    document.getElementById('fps').textContent = fps;
                    frameCount = 0;
                    lastTime = currentTime;
                }
                gameUPS = performanceDataLocal.updateIntervalCountsTimes;
                document.getElementById('gameUPS').textContent = gameUPS;
                
                let totalTimeAddShowContent = '';
                const totalTimeAddShowContentList = [Number(performanceDataLocal.gridResetTimeAverage.toFixed(2)), Number(performanceDataLocal.getNearbyTimeAverage.toFixed(2)), Number(performanceDataLocal.gAffectCalcTimeAverage.toFixed(2)), Number(performanceDataLocal.positionUpdateTimeAverage.toFixed(2)), Number(performanceDataLocal.particleCollisionTimeAverage.toFixed(2)), Number(performanceDataLocal.ParticleAffcetCalcTimeAverage.toFixed(2))];
                totalTimeAddShowContent += `${totalTimeAddShowContentList.join(' + ')}<br><br>`;
                let sum = 0;
                for (let i = 2; i <= totalTimeAddShowContentList.length; i++) {
                    sum = totalTimeAddShowContentList.slice(0, i).reduce((a, b) => a + b, 0);
                    totalTimeAddShowContent += `${Number(sum.toFixed(2))}${totalTimeAddShowContentList.slice(i).length > 0 ? ` + ${totalTimeAddShowContentList.slice(i).join(' + ')}` : ''}<br><br>`;
                }
                document.getElementById('total-time-add-show').innerHTML = totalTimeAddShowContent;

                requestAnimationFrame(() => {
                    worker.postMessage({ type: 'canUpdate' });
                    update();
                });
            }

            // 接收來自 Worker 的消息
            worker.onmessage = function (e) {
                if (e.data.type === 'update') {
                    particles = e.data.particles;
                    gameState.particleGroups = e.data.particleGroups;
                    gameState.gridData.nearbyCells = e.data.nearbyCells;
                    //console.log(`e.data.nearbyCellsSkipped: ${e.data.nearbyCellsSkipped}`);
                    gameState.gridData.nearbyCellsSkipped = e.data.nearbyCellsSkipped;
                    //console.log(`gameState.gridData.nearbyCellsSkipped: ${gameState.gridData.nearbyCellsSkipped}`);
                    gameState.gridData.radiusCells = e.data.radiusCells;
                    gameState.gridData.width = e.data.gridDataWidth;
                    gameState.gridData.height = e.data.gridDataHeight;
                    //console.log(`before performanceDataLocal.totalTimeAverage: ${performanceDataLocal.totalTimeAverage}`);
                    performanceData = e.data.performanceData;
                    //console.log(`after performanceDataLocal.totalTimeAverage: ${performanceDataLocal.totalTimeAverage}`);
                    if (gameState.enableParticleAffcetRadiusShow){
                        gameState.nearbyParticlesList = e.data.nearbyParticlesList;
                        for (let i = 0; i < gameState.nearbyParticlesList.length; i++) {
                            //console.log(`gameState.nearbyParticlesList[${i}]: ${gameState.nearbyParticlesList[i]}`);
                            document.getElementById(`particle-nearby-particles-${i}`).textContent = `範圍內的類型${i + 1}粒子數量: ${gameState.nearbyParticlesList[i] ? gameState.nearbyParticlesList[i].length : 0}`;
                        }
                    }

                    // 更新網格寬度和高度的顯示
                    document.getElementById('grid-width').textContent = gameState.gridData.width;
                    document.getElementById('grid-height').textContent = gameState.gridData.height;
                    if (gameState.gridData.radiusCells){
                        document.getElementById('grid-radius-cells').textContent = `${gameState.gridData.radiusCells}`;
                    }
                }
                if (e.data.type === 'updateCellSize') {
                    gameState.gridData.cellSize = e.data.cellSize;
                    document.getElementById('cell-size').value = gameState.gridData.cellSize;
                    document.getElementById('cell-size').dispatchEvent(new Event('input'));
                }
                if (e.data.type === 'setMovingCanvas') {
                    gameState.isMovingCanvas = e.data.isMovingCanvas;
                }
                if (e.data.type === 'updateUpdateIntervalCountsTimes') {
                    performanceDataLocal.updateIntervalCountsTimes = e.data.updateIntervalCountsTimes;
                }
            };

            // 更新規則
            function updateRules() {
                // 使用 gameState 中的矩陣數據
                worker.postMessage({
                    type: 'updateRules',
                    forceMatrix: gameState.forceMatrix,
                    distanceMatrix: gameState.distanceMatrix
                });
            }

            
            

            // 隨機化值
            function randomizeValues() {
                document.querySelectorAll('.particle-force').forEach(p => {
                    const value = (Math.random() * 2 - 1).toFixed(1);
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                document.querySelectorAll('.particle-distance').forEach(p => {
                    const value = Math.floor(Math.random() * (300 - 10 + 1)) + 10;
                    p.value = value;
                    p.dispatchEvent(new Event('input'));
                });
                updateRules();
            }

            // 隨機化並重新開始
            function randomizeAndRestart() {
                randomizeValues();
                initGame();
            }

            // 控制板切換
            const toggleButton = document.getElementById('toggle-controls');
            const controlPanel = document.getElementById('controls');

            toggleButton.addEventListener('click', () => {
                controlPanel.classList.toggle('visible');
                if (controlPanel.classList.contains('visible')) {
                    toggleButton.style.right = '310px';
                    toggleButton.textContent = '✕';
                } else {
                    toggleButton.style.right = '10px';
                    toggleButton.textContent = '☰';
                }
                updateCanvasSize();
            });

            // 自動隱藏切換按鈕
            let hideTimeout;
            document.addEventListener('mousemove', () => {
                toggleButton.style.opacity = '0.5';
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    toggleButton.style.opacity = '0';
                }, 3000);
            });

            // 匯出規則
            function exportRules() {
                const rules = {};
                // 添加規則
                rules['forceMatrix'] = gameState.forceMatrix;
                rules['distanceMatrix'] = gameState.distanceMatrix;
                // 添加粒子數量
                rules['particleCounts'] = gameState.particleCounts;
                // 添加粒子類型
                rules['particleTypes'] = gameState.particleTypes;
                // 添加粒子顏色
                rules['particleColors'] = gameState.particleColors;
                // 添加穿透模式狀態
                rules['isThrough'] = gameState.isThrough;
                rules['tHalf'] = gameState.tHalf;
                rules['dt'] = gameState.dt;
                rules['mouseForce'] = gameState.mouseForce;
                rules['gridData'] = gameState.gridData;

                // 添加顏色
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(rules));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "particle_rules.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            // 導入規則
            function importRules(shouldRestart) {
                const fileInput = document.getElementById('import-file');
                fileInput.value = '';
                fileInput.dataset.shouldRestart = shouldRestart;
                fileInput.click();
            }

            function handleFileSelect(event) {
                //console.log('handleFileSelect');
                const file = event.target.files[0];
                const shouldRestart = event.target.dataset.shouldRestart === 'true';
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const rules = JSON.parse(e.target.result);
                        Object.keys(rules).forEach(id => {
                            if (id === 'isThrough') {
                                // 設置穿透模式狀態
                                gameState.isThrough = rules[id];
                            } else if (id === 'particleCounts') {
                                gameState.particleCounts = rules[id];
                            } else if (id === 'particleTypes') {
                                gameState.particleTypes = rules[id];
                            } else if (id === 'particleColors') {
                                gameState.particleColors = rules[id];
                            } else if (id === 'tHalf') {
                                gameState.tHalf = rules[id];
                            } else if (id === 'dt') {
                                gameState.dt = rules[id];
                            } else if (id === 'mouseForce') {
                                gameState.mouseForce = rules[id];
                            } else if (id === 'gridData') {
                                gameState.gridData = rules[id];
                            } else if (/force(Matrix)*?/.test(id)) {
                                gameState.forceMatrix = rules[id];
                            } else if (/distance(Matrix)*?/.test(id)) {
                                gameState.distanceMatrix = rules[id];
                            }
                        });
                        gameState.gridData.selectedCell = null;
                        //console.log('updateParticleSystem');
                        updateParticleSystem();
                        //console.log('updateEveryThing');
                        updateEveryThing();
                        if (shouldRestart) {
                            setTimeout(initGame, 100);
                        }
                    };
                    reader.readAsText(file);
                }
            }

            // 更新HTML
            function updateHTML(){
                const throughCheckbox = document.getElementById('isThrough');
                const particleTypes = document.getElementById('particle-types');
                const cellSize = document.getElementById('cell-size');
                const setectGridDistance = document.getElementById('setectGridDistance');
                const updateInterval = document.getElementById('updateInterval');
                const tHalf = document.getElementById('t-half');
                const mouseForce = document.getElementById('mouse-force');

                particleTypes.value = gameState.particleTypes;
                throughCheckbox.checked = gameState.isThrough;
                throughCheckbox.dispatchEvent(new Event('change'));
                cellSize.value = gameState.gridData.cellSize;
                cellSize.dispatchEvent(new Event('input'));
                setectGridDistance.value = gameState.setectGridDistance;
                setectGridDistance.dispatchEvent(new Event('input'));
                updateInterval.value = gameState.updateInterval;
                updateInterval.dispatchEvent(new Event('input'));
                tHalf.value = gameState.tHalf;
                tHalf.dispatchEvent(new Event('input'));
                mouseForce.value = gameState.mouseForce;
                mouseForce.dispatchEvent(new Event('input'));

            }

            // 更新顏色
            function updateColors() {
                //console.log(`index.html: gameState.particleColors: ${gameState.particleColors}`);
                worker.postMessage({
                    type: 'updateColors',
                    particleColors: gameState.particleColors
                });
            }

            // 為匯出規則添加事件監聽器
            document.getElementById('export-rules').addEventListener('click', exportRules);
            // 為導入規則添加事件監聽器
            document.getElementById('import-rules').addEventListener('click', () => importRules(false));
            // 為導入規則並重新開始添加事件監聽器
            document.getElementById('import-rules-and-restart').addEventListener('click', () => importRules(true));
            // 為導入文件添加事件監聽器
            document.getElementById('import-file').addEventListener('change', handleFileSelect);

            let mouseX = 0;
            let mouseY = 0;
            let isMouseDown = false;
            let isUpdateMouse = false;
            let isUpdateMouseDownUp = false;

            // 穿透模式切換
            const throughCheckbox = document.getElementById("isThrough");
            throughCheckbox.addEventListener('change', () => {
                gameState.isThrough = throughCheckbox.checked;
                worker.postMessage({ type: 'setThrough', isThrough: gameState.isThrough });
            });

            // 使用網格功能切換
            const isUsingGridCheckbox = document.getElementById("isUsingGrid");
            isUsingGridCheckbox.addEventListener('change', () => {
                gameState.isUsingGrid = isUsingGridCheckbox.checked;
                setTimeout(() => {
                    worker.postMessage({ type: 'setIsUsingGrid', isUsingGrid: gameState.isUsingGrid });
                }, 100);
            });

            // 運算模式切換
            const threadModeSelect = document.getElementById("threadMode");

            // 初始化選擇值
            threadModeSelect.value = gameState.threadMode;

            // 添加事件監聽器
            threadModeSelect.addEventListener('change', async () => {
                const newMode = threadModeSelect.value;
                const currentMode = gameState.threadMode;
                
                if (newMode === currentMode) return;

                gameState.threadMode = newMode;

                // 終止當前 worker
                if (worker) {
                    worker.terminate();
                }

                // 根據選擇的模式初始化相應的 worker
                switch (newMode) {
                    case "multithread":
                        worker = new Worker('particleWorker_Multithread.js');
                        break;
                        
                    case "singlethread":
                        worker = new Worker('particleWorker_Singlethread.js');
                        break;
                        
                    case "multithread_gpu":
                        // 預留給 GPU 加速模式
                        console.log("GPU acceleration mode is under development");
                        return;
                        
                    case "multithread_wasm":
                        // 預留給 WebAssembly 模式
                        console.log("WebAssembly mode is under development");
                        return;
                        
                    default:
                        console.error("Unknown thread mode:", newMode);
                        return;
                }

                // 初始化新的 worker
                worker.postMessage({ 
                    type: 'changeThreadInit',
                    particleGroups: gameState.particleGroups,
                    canvasWidth: canvas2d.width,
                    canvasHeight: canvas2d.height,
                    particleTypes: gameState.particleTypes,
                    particleColors: gameState.particleColors,
                    particleCounts: gameState.particleCounts,
                    cellSize: gameState.gridData.cellSize,
                    performanceData: performanceData,
                    isUsingGrid: gameState.isUsingGrid,
                });

                // 更新所有相關狀態
                updateEveryThing();
            });
             
            // 添加按鈕事件監聽器
            document.getElementById('randomize-button').addEventListener('click', randomizeValues);
            document.getElementById('restart-button').addEventListener('click', initGame);
            document.getElementById('randomize-and-restart-button').addEventListener('click', randomizeAndRestart);
            document.addEventListener("keydown", function(event) {
                if (event.key === "r") {
                    randomizeValues();
                }
                if (event.key === "s") {
                    initGame();
                }
                if (event.key === "f") {
                    randomizeAndRestart();
                }
                if (event.key === "x") {
                    isUpdateMouseDownUp = false;
                }
                if (event.key === "z") {
                    isUpdateMouse = false;
                }
                if (event.key === "t") {
                    throughCheckbox.checked = !throughCheckbox.checked;
                    throughCheckbox.dispatchEvent(new Event('change'));
                }
                if (event.key === "g") {
                    isUsingGridCheckbox.checked = !isUsingGridCheckbox.checked;
                    isUsingGridCheckbox.dispatchEvent(new Event('change'));
                }
                if (event.key === "m") {
                    const currentIndex = threadModeSelect.selectedIndex;
                    let nextIndex = (currentIndex + 1) % threadModeSelect.options.length;
                    let nextOption = threadModeSelect.options[nextIndex];
                    
                    while (nextOption.disabled) {
                        nextIndex = (nextIndex + 1) % threadModeSelect.options.length;
                        nextOption = threadModeSelect.options[nextIndex];
                    }
                    threadModeSelect.selectedIndex = nextIndex;
                    threadModeSelect.dispatchEvent(new Event('change'));
                }
            });

            // 添加滑鼠事件監聽器
            canvas2d.addEventListener('mousedown', (e) => {
                if (!gameState.enableParticleAffcetRadiusShow){
                    isUpdateMouseDownUp = true;
                    isUpdateMouse = true;
                    isMouseDown = true;
                    updateMousePosition(e);
                }
            });

            canvas2d.addEventListener('mouseup', () => {
                if (isUpdateMouseDownUp) {
                    isMouseDown = false;
                    worker.postMessage({ type: 'setMouseInactive' });
                }
            });

            canvas2d.addEventListener('mousemove', (e) => {
                if (isUpdateMouse) {
                    updateMousePosition(e);
                }
            });

            function updateMousePosition(e) {
                const rect = canvas2d.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                if (isMouseDown) {
                    worker.postMessage({ type: 'updateMousePosition', x: mouseX, y: mouseY });
                }
            }

            function updateMouseForce(){
                worker.postMessage({ type: 'updateMouseForce', force: gameState.mouseForce });
            }
            function updateCellSize(){
                worker.postMessage({ type: 'updateCellSize', size: gameState.gridData.cellSize });
            }
            function updateSetectGridDistance(){
                worker.postMessage({ type: 'updateSetectGridDistance', distance: gameState.setectGridDistance });
            }
            function updateUpdateInterval(){
                worker.postMessage({ type: 'updateUpdateInterval', interval: gameState.updateInterval });
            }
            function updateDt(){
                worker.postMessage({ type: 'updateDt', dt: gameState.dt });
            }
            function updateBallRadius(){
                worker.postMessage({ type: 'updateBallRadius', ballRadius: gameState.ballRadius });
            }
            function updateRadiusShow(){
                worker.postMessage({ type: 'updateRadiusShow', RadiusShow: gameState.RadiusShow });
            }
            function updateTHalf(){
                worker.postMessage({ type: 'updateTHalf', tHalf: gameState.tHalf });
            }
            function updateIsUsingGrid(){
                worker.postMessage({ type: 'setIsUsingGrid', isUsingGrid: gameState.isUsingGrid });
            }

            /* not used
            function updateIsUsingMultithread(){
                worker.postMessage({ type: 'setIsUsingMultithread', isUsingMultithread: gameState.isUsingMultithread });
            }
            */

            function updateEveryThing(){
                updateHTML();
                updateRules();
                updateColors();
                updateMouseForce();
                updateCellSize();
                updateSetectGridDistance();
                updateUpdateInterval();
                updateBallRadius();
                updateRadiusShow();
                updateTHalf();
                updateDt();
                updateIsUsingGrid();
            }

            // 為滑鼠力量滑塊添加事件監聽器
            const mouseForceSlider = document.getElementById('mouse-force');
            const mouseForceNumber = document.getElementById('mouse-force-number');
            mouseForceSlider.addEventListener('input', () => {
                mouseForceNumber.value = mouseForceSlider.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceSlider.value) });
            });
            mouseForceNumber.addEventListener('input', () => {
                mouseForceSlider.value = mouseForceNumber.value;
                worker.postMessage({ type: 'updateMouseForce', force: parseFloat(mouseForceNumber.value) });
            });

            // 為網格大小滑塊添加事件監聽器
            const cellSizeSlider = document.getElementById('cell-size');
            const cellSizeNumber = document.getElementById('cell-size-number');
            cellSizeSlider.addEventListener('input', () => {
                cellSizeNumber.value = cellSizeSlider.value;
                gameState.gridData.cellSize = parseInt(cellSizeSlider.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeSlider.value) });
            }); 
            cellSizeNumber.addEventListener('input', () => {
                cellSizeSlider.value = cellSizeNumber.value;
                gameState.gridData.cellSize = parseInt(cellSizeNumber.value);
                worker.postMessage({ type: 'updateCellSize', size: parseInt(cellSizeNumber.value) });
            });

            // 為選中網格距離滑塊添加事件監聽器
            const setectGridDistanceSlider = document.getElementById('setectGridDistance');
            const setectGridDistanceNumber = document.getElementById('setectGridDistance-number');
            setectGridDistanceSlider.addEventListener('input', () => {
                setectGridDistanceNumber.value = setectGridDistanceSlider.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceSlider.value) });
            });
            setectGridDistanceNumber.addEventListener('input', () => {
                setectGridDistanceSlider.value = setectGridDistanceNumber.value;
                worker.postMessage({ type: 'updateSetectGridDistance', distance: parseInt(setectGridDistanceNumber.value) });
            })

            // 為更新間隔滑塊添加事件監聽器
            const updateIntervalSlider = document.getElementById('updateInterval');
            const updateIntervalNumber = document.getElementById('updateInterval-number');
            const updateIntervalText = document.getElementById('updateInterval-text');
            updateIntervalSlider.addEventListener('input', () => {
                const value = updateIntervalSlider.value;
                if (value == 0) {
                    updateIntervalNumber.value = null;
                    updateIntervalText.value = "無上限";
                } else {
                    updateIntervalNumber.value = value;
                    updateIntervalText.value = '';
                }
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(value == 0 ? 0 : 1000 / value) });
            });
            updateIntervalNumber.addEventListener('input', () => {
                const value = updateIntervalNumber.value;
                updateIntervalSlider.value = value;
                if (value == 0) {
                    updateIntervalText.value = "無上限";
                    updateIntervalNumber.value = null;
                } else {
                    updateIntervalText.value = '';
                }
                worker.postMessage({ type: 'updateUpdateInterval', interval: parseInt(value == 0 ? 0 : 1000 / value) });
            });

            // 添加t_half控制事件監聽器
            document.getElementById('t-half').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half-number').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });

            document.getElementById('t-half-number').addEventListener('input', (e) => {
                const tHalf = parseFloat(e.target.value);
                document.getElementById('t-half').value = tHalf;
                worker.postMessage({ type: 'updateTHalf', tHalf: tHalf });
            });
            
            // 添加網格顯示切換
            const showGridCheckbox = document.getElementById('showGrid');
            showGridCheckbox.addEventListener('change', () => {
                gameState.showGrid = showGridCheckbox.checked;
                worker.postMessage({ type: 'toggleGrid', show: gameState.showGrid });
            });

            const enableParticleAffcetRadiusShowCheckbox = document.getElementById('enableParticleAffcetRadiusShow');
            enableParticleAffcetRadiusShowCheckbox.addEventListener('change', () => {
                gameState.enableParticleAffcetRadiusShow = enableParticleAffcetRadiusShowCheckbox.checked;
                worker.postMessage({ type: 'toggleParticleAffcetRadiusShow', enable: gameState.enableParticleAffcetRadiusShow });
            });

            /*
            const isOneRadiusShowCheckbox = document.getElementById('isOneRadiusShow');
            isOneRadiusShowCheckbox.addEventListener('change', () => {
                isOneRadiusShow = isOneRadiusShowCheckbox.checked;
            });
            const isTwoRadiusShowCheckbox = document.getElementById('isTwoRadiusShow');
            isTwoRadiusShowCheckbox.addEventListener('change', () => {
                isTwoRadiusShow = isTwoRadiusShowCheckbox.checked;
            });
            const isThreeRadiusShowCheckbox = document.getElementById('isThreeRadiusShow');
            isThreeRadiusShowCheckbox.addEventListener('change', () => {
                isThreeRadiusShow = isThreeRadiusShowCheckbox.checked;
            });
            */
           
            function initializeMatrices(types, oldForceMatrix, oldDistanceMatrix) {
                forceMatrix = new Array(types);
                for (let i = 0; i < types; i++) {
                    forceMatrix[i] = new Array(types);
                    for (let j = 0; j < types; j++) {
                        // Keep old force value if available, otherwise use 0
                        forceMatrix[i][j] = oldForceMatrix && i < oldForceMatrix.length && j < oldForceMatrix[i].length ? 
                            oldForceMatrix[i][j] : Math.random()*2-1;
                    }
                }
                gameState.forceMatrix = forceMatrix;
                //console.log(`index.html: forceMatrix: ${forceMatrix}`);
                
                distanceMatrix = new Array(types);
                for (let i = 0; i < types; i++) {
                    distanceMatrix[i] = new Array(types);
                    for (let j = 0; j < types; j++) {
                        // Keep old distance value if available, otherwise use 100
                        distanceMatrix[i][j] = oldDistanceMatrix && i < oldDistanceMatrix.length && j < oldDistanceMatrix[i].length ?
                            oldDistanceMatrix[i][j] : 150;
                    }
                }
                gameState.distanceMatrix = distanceMatrix;
                //console.log(`index.html: distanceMatrix: ${distanceMatrix}`);
                
                particleGroups = new Array(types);
                for (let i = 0; i < types; i++) {
                    particleGroups[i] = [];
                }
                gameState.particleGroups = particleGroups;
                //console.log(`index.html: particleGroups: ${particleGroups}`);
            }
            function initializeColors(types) {
                particleColors = new Array(types);
                for (let i = 0; i < types; i++) {
                    particleColors[i] = `hsl(${i * 360 / types}, 100%, 50%)`;
                }
                gameState.particleColors = particleColors;
            }
            function initializeParticleCounts(types) {
                particleCounts = new Array(types);
                for (let i = 0; i < types; i++) {
                    particleCounts[i] = gameState.particleCounts[i] || 250;
                }
                gameState.particleCounts = particleCounts;
            }
            // 添加粒子類型數量監聽器
            document.getElementById('particle-types').addEventListener('input', (e) => {
                const types = parseInt(e.target.value);
                gameState.particleTypes = types;
                initializeColors(types);
                initializeMatrices(types, gameState.forceMatrix, gameState.distanceMatrix);
                initializeParticleCounts(types);
                updateParticleSystem();
                updateEveryThing();
                initGame();
            });

            // 修改單元格選擇功能
            canvas2d.addEventListener('click', (e) => {
                if (gameState.showGrid) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const cellX = Math.floor(x / gameState.gridData.cellSize);
                    const cellY = Math.floor(y / gameState.gridData.cellSize);
                    gameState.gridData.selectedCell = { x: cellX, y: cellY };
                    worker.postMessage({ 
                        type: 'selectCell', 
                        cell: gameState.gridData.selectedCell,
                    });
                    
                    // 直接更新顯示，以提供即時反饋
                    document.getElementById('selected-cell').textContent = `x: ${cellX}, y: ${cellY}`;
                }
                
                if (gameState.enableParticleAffcetRadiusShow) {
                    const rect = canvas2d.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // 找到最近的粒子
                    selectedParticle = particles.reduce((closest, particle) => {
                        const dx = particle.x - x;
                        const dy = particle.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return (distance < closest.distance)&&(distance < 10) ? { particle, distance } : closest;
                    }, { particle: null, distance: Infinity }).particle;
                    if (selectedParticle) {
                        gameState.selectedParticleId = selectedParticle.id;
                        gameState.selectedParticleType = selectedParticle.type;
                        document.getElementById('selectedParticleId').textContent = gameState.selectedParticleId;
                        // 請求 worker 計算附近的粒子
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: gameState.selectedParticleId,
                        });
                    } else {
                        document.getElementById('selectedParticleId').textContent = '無';
                        gameState.selectedParticleId = null;
                        gameState.selectedParticleType = null;
                        worker.postMessage({ 
                            type: 'updateSelectedParticle', 
                            particleId: null,
                        });
                        gameState.nearbyParticlesList = [];
                    }
                }
            });

            // 初始化遊戲並開始更新循環
            updateParticleSystem();
            updateEveryThing();
            initGame();
            update();

            // 創建粒子類型控制界面
            function createParticleTypeControls(type, total, min, max, step, count) {
                const defaultColor = gameState.particleColors[type];
                
                return `
                    <div class="particle-type" data-type="${type}">
                        <h4>類型 ${type + 1}</h4>
                        <div>
                            <label>數量:</label>
                            <input type="range" class="particle-count" min="${min}" max="${max}" step="${step}" value="${count}">
                            <input type="number" class="particle-count-number" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${count}">
                        </div>
                        <div>
                            <label>顏色:</label>
                            <div class="color-inputs">
                                <input type="color" class="particle-color" value="${hslToHex(defaultColor)}">
                                <span class="hsl-display">${defaultColor}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            function createMatrixTable(types, matrixType, min, max, step, matrix){
                let html = '<table class="matrix-container">';
                for (let i = 0; i < types; i++) {
                    html += `<tr>`;
                    for (let j = 0; j < types; j++) {
                        html += `<td><input type="number" class="matrix-input ${matrixType}" data-i="${i}" data-j="${j}" min="${min}" max="${max}" step="${step}" onkeyup="if(this.value>${max}){this.value=${max}}else if(this.value<${min}){this.value=${min}}" value="${matrix[i][j]}"></td>`;
                    }
                    html += `</tr>`;
                }
                html += '</table>';
                return html;
            }

            // 更新粒子系統
            function updateParticleSystem() {
                const types = gameState.particleTypes;
                const particleSettings = document.getElementById('particle-settings');
                const interactionMatrix = document.getElementById('interaction-matrix');
                const particleAffcetRadiusShow = document.getElementById('particle-affcet-radius-show');
                const particleNearbyParticles = document.getElementById('particle-nearby-particles');
                for (let i = 0; i < types; i++) {
                    gameState.RadiusShow[i] = gameState.RadiusShow[i] || true;
                };
                
                // 更新粒子類型控制
                particleSettings.innerHTML = '';
                for (let i = 0; i < types; i++) {
                    particleSettings.innerHTML += createParticleTypeControls(i, types, 0, 500, 10, gameState.particleCounts[i]);
                }
                
                // 更新交互矩陣
                interactionMatrix.innerHTML = `
                    <div class="matrix-table">  
                        <h4>粒子引力</h4>
                        <p class="description">數值越大，粒子越容易聚集在一起</p>
                        ${createMatrixTable(types, 'particle-force', -1, 1, 0.05, gameState.forceMatrix)}
                    </div>

                    <div class="matrix-table">
                        <h4>粒子距離</h4>
                        <p class="description">數值越大，引力范圍越大</p>
                        ${createMatrixTable(types, 'particle-distance', 10, 300, 10, gameState.distanceMatrix)}
                    </div>
                `;
                
                particleAffcetRadiusShow.innerHTML = '';
                for (let i = 0; i < types; i++) {
                    particleAffcetRadiusShow.innerHTML += `
                        <div class="particle-affcet-radius-show">
                            <label for="show-particle-affcet-radius-${i}">顯示類型${i + 1}粒子影響範圍</label>
                            <input type="checkbox" class="show-particle-affcet-radius" id="show-particle-affcet-radius-${i}" data-type="${i}" checked>
                        </div>
                    `;
                }
                particleNearbyParticles.innerHTML = "";
                for (let i = 0; i < types; i++) {
                    particleNearbyParticles.innerHTML += `
                        <p class="particle-nearby-particles" id="particle-nearby-particles-${i}">範圍內的類型${i + 1}粒子數量: N/A</p>
                    `;
                }
                
                // 添加事件監聽器
                setupParticleControlEventListeners();
                setupMatrixEventListeners();
                setupParticleAffcetRadiusShowEventListeners();
            }
            // 設置粒子控制的事件監聽器
            function setupParticleControlEventListeners() {
                // 數量控制
                document.querySelectorAll('.particle-count').forEach(input => {
                    const numberInput = input.parentElement.querySelector('.particle-count-number');
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    
                    input.addEventListener('input', (e) => {
                        const value = e.target.value;
                        numberInput.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                    
                    numberInput.addEventListener('input', (e) => {
                        const value = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        input.value = value;
                        gameState.particleCounts[type] = value;
                        initGame();
                    });
                });

                // 顏色控制
                document.querySelectorAll('.particle-color').forEach(input => {
                    const type = parseInt(input.closest('.particle-type').dataset.type);
                    const hslDisplay = input.parentElement.querySelector('.hsl-display');
                    
                    input.addEventListener('input', (e) => {
                        const hsl = hexToHsl(e.target.value);
                        gameState.particleColors[type] = hsl;
                        hslDisplay.textContent = hsl;
                        worker.postMessage({
                            type: 'updateColors',
                            particleColors: gameState.particleColors
                        });
                    });
                });
            }
            // 設置矩陣輸入的事件監聽器
            function setupMatrixEventListeners() {
                document.querySelectorAll('.particle-force').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const force = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        gameState.forceMatrix[i][j] = parseFloat(force);
                        updateRules();
                    });
                });

                document.querySelectorAll('.particle-distance').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const i = parseInt(e.target.dataset.i);
                        const j = parseInt(e.target.dataset.j);
                        const distance = Math.min(Math.max(parseFloat(e.target.value) || 0, parseFloat(e.target.min)), parseFloat(e.target.max));
                        gameState.distanceMatrix[i][j] = parseFloat(distance);
                        updateRules();
                    });
                });
            }
            // 設置粒子影響範圍顯示的事件監聽器
            function setupParticleAffcetRadiusShowEventListeners() {
                document.querySelectorAll('.show-particle-affcet-radius').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const type = parseInt(e.target.dataset.type);
                        gameState.RadiusShow[type] = e.target.checked;
                        worker.postMessage({
                            type: 'updateRadiusShow',
                            RadiusShow: gameState.RadiusShow
                        });
                    });
                });
            }

            // HSL 轉 Hex 顏色函數
            function hslToHex(hsl) {
                const match = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!match) return '#000000';
                
                const h = parseInt(match[1]) / 360;
                const s = parseInt(match[2]) / 100;
                const l = parseInt(match[3]) / 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            // Hex 轉 HSL 顏色函數
            function hexToHsl(hex) {
                // 移除 # 號（如果有的話）
                hex = hex.replace(/^#/, '');
                
                // 解析 RGB 值
                const bigint = parseInt(hex, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                
                // 轉換為 0-1 範圍
                const rr = r / 255;
                const gg = g / 255;
                const bb = b / 255;
                
                const max = Math.max(rr, gg, bb);
                const min = Math.min(rr, gg, bb);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case rr: h = (gg - bb) / d + (gg < bb ? 6 : 0); break;
                        case gg: h = (bb - rr) / d + 2; break;
                        case bb: h = (rr - gg) / d + 4; break;
                    }
                    
                    h /= 6;
                }
                
                return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
            }
        });
    </script>
</body>

</html>
